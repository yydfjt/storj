// AUTOGENERATED BY gopkg.in/spacemonkeygo/dbx.v1
// DO NOT EDIT.

package satellitedb

import (
	"bytes"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
	"unicode"

	"github.com/lib/pq"

	"github.com/mattn/go-sqlite3"
	"math/rand"
)

// Prevent conditional imports from causing build failures
var _ = strconv.Itoa
var _ = strings.LastIndex
var _ = fmt.Sprint
var _ sync.Mutex

var (
	WrapErr = func(err *Error) error { return err }
	Logger  func(format string, args ...interface{})

	errTooManyRows       = errors.New("too many rows")
	errUnsupportedDriver = errors.New("unsupported driver")
	errEmptyUpdate       = errors.New("empty update")
)

func logError(format string, args ...interface{}) {
	if Logger != nil {
		Logger(format, args...)
	}
}

type ErrorCode int

const (
	ErrorCode_Unknown ErrorCode = iota
	ErrorCode_UnsupportedDriver
	ErrorCode_NoRows
	ErrorCode_TxDone
	ErrorCode_TooManyRows
	ErrorCode_ConstraintViolation
	ErrorCode_EmptyUpdate
)

type Error struct {
	Err         error
	Code        ErrorCode
	Driver      string
	Constraint  string
	QuerySuffix string
}

func (e *Error) Error() string {
	return e.Err.Error()
}

func wrapErr(e *Error) error {
	if WrapErr == nil {
		return e
	}
	return WrapErr(e)
}

func makeErr(err error) error {
	if err == nil {
		return nil
	}
	e := &Error{Err: err}
	switch err {
	case sql.ErrNoRows:
		e.Code = ErrorCode_NoRows
	case sql.ErrTxDone:
		e.Code = ErrorCode_TxDone
	}
	return wrapErr(e)
}

func unsupportedDriver(driver string) error {
	return wrapErr(&Error{
		Err:    errUnsupportedDriver,
		Code:   ErrorCode_UnsupportedDriver,
		Driver: driver,
	})
}

func emptyUpdate() error {
	return wrapErr(&Error{
		Err:  errEmptyUpdate,
		Code: ErrorCode_EmptyUpdate,
	})
}

func tooManyRows(query_suffix string) error {
	return wrapErr(&Error{
		Err:         errTooManyRows,
		Code:        ErrorCode_TooManyRows,
		QuerySuffix: query_suffix,
	})
}

func constraintViolation(err error, constraint string) error {
	return wrapErr(&Error{
		Err:        err,
		Code:       ErrorCode_ConstraintViolation,
		Constraint: constraint,
	})
}

type driver interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

var (
	notAPointer     = errors.New("destination not a pointer")
	lossyConversion = errors.New("lossy conversion")
)

type DB struct {
	*sql.DB
	dbMethods

	Hooks struct {
		Now func() time.Time
	}
}

func Open(driver, source string) (db *DB, err error) {
	var sql_db *sql.DB
	switch driver {
	case "postgres":
		sql_db, err = openpostgres(source)
	case "sqlite3":
		sql_db, err = opensqlite3(source)
	default:
		return nil, unsupportedDriver(driver)
	}
	if err != nil {
		return nil, makeErr(err)
	}
	defer func(sql_db *sql.DB) {
		if err != nil {
			sql_db.Close()
		}
	}(sql_db)

	if err := sql_db.Ping(); err != nil {
		return nil, makeErr(err)
	}

	db = &DB{
		DB: sql_db,
	}
	db.Hooks.Now = time.Now

	switch driver {
	case "postgres":
		db.dbMethods = newpostgres(db)
	case "sqlite3":
		db.dbMethods = newsqlite3(db)
	default:
		return nil, unsupportedDriver(driver)
	}

	return db, nil
}

func (obj *DB) Close() (err error) {
	return obj.makeErr(obj.DB.Close())
}

func (obj *DB) Open(ctx context.Context) (*Tx, error) {
	tx, err := obj.DB.Begin()
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return &Tx{
		Tx:        tx,
		txMethods: obj.wrapTx(tx),
	}, nil
}

func (obj *DB) NewRx() *Rx {
	return &Rx{db: obj}
}

func DeleteAll(ctx context.Context, db *DB) (int64, error) {
	tx, err := db.Open(ctx)
	if err != nil {
		return 0, err
	}
	defer func() {
		if err == nil {
			err = db.makeErr(tx.Commit())
			return
		}

		if err_rollback := tx.Rollback(); err_rollback != nil {
			logError("delete-all: rollback failed: %v", db.makeErr(err_rollback))
		}
	}()
	return tx.deleteAll(ctx)
}

type Tx struct {
	Tx *sql.Tx
	txMethods
}

type dialectTx struct {
	tx *sql.Tx
}

func (tx *dialectTx) Commit() (err error) {
	return makeErr(tx.tx.Commit())
}

func (tx *dialectTx) Rollback() (err error) {
	return makeErr(tx.tx.Rollback())
}

type postgresImpl struct {
	db      *DB
	dialect __sqlbundle_postgres
	driver  driver
}

func (obj *postgresImpl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *postgresImpl) logStmt(stmt string, args ...interface{}) {
	postgresLogStmt(stmt, args...)
}

func (obj *postgresImpl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type postgresDB struct {
	db *DB
	*postgresImpl
}

func newpostgres(db *DB) *postgresDB {
	return &postgresDB{
		db: db,
		postgresImpl: &postgresImpl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *postgresDB) Schema() string {
	return `CREATE TABLE accounting_raws (
	id bigserial NOT NULL,
	node_id bytea NOT NULL,
	interval_end_time timestamp with time zone NOT NULL,
	data_total double precision NOT NULL,
	data_type integer NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE accounting_rollups (
	id bigserial NOT NULL,
	node_id bytea NOT NULL,
	start_time timestamp with time zone NOT NULL,
	put_total bigint NOT NULL,
	get_total bigint NOT NULL,
	get_audit_total bigint NOT NULL,
	get_repair_total bigint NOT NULL,
	put_repair_total bigint NOT NULL,
	at_rest_total double precision NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE accounting_timestamps (
	name text NOT NULL,
	value timestamp with time zone NOT NULL,
	PRIMARY KEY ( name )
);
CREATE TABLE bucket_bandwidth_rollups (
	bucket_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	interval_seconds integer NOT NULL,
	action integer NOT NULL,
	inline bigint NOT NULL,
	allocated bigint NOT NULL,
	settled bigint NOT NULL,
	PRIMARY KEY ( bucket_id, interval_start, action )
);
CREATE TABLE bucket_storage_tallies (
	bucket_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	inline bigint NOT NULL,
	remote bigint NOT NULL,
	remote_segments_count integer NOT NULL,
	inline_segments_count integer NOT NULL,
	object_count integer NOT NULL,
	metadata_size bigint NOT NULL,
	PRIMARY KEY ( bucket_id, interval_start )
);
CREATE TABLE bucket_usages (
	id bytea NOT NULL,
	bucket_id bytea NOT NULL,
	rollup_end_time timestamp with time zone NOT NULL,
	remote_stored_data bigint NOT NULL,
	inline_stored_data bigint NOT NULL,
	remote_segments integer NOT NULL,
	inline_segments integer NOT NULL,
	objects integer NOT NULL,
	metadata_size bigint NOT NULL,
	repair_egress bigint NOT NULL,
	get_egress bigint NOT NULL,
	audit_egress bigint NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE bwagreements (
	serialnum text NOT NULL,
	storage_node_id bytea NOT NULL,
	uplink_id bytea NOT NULL,
	action bigint NOT NULL,
	total bigint NOT NULL,
	created_at timestamp with time zone NOT NULL,
	expires_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( serialnum )
);
CREATE TABLE certRecords (
	publickey bytea NOT NULL,
	id bytea NOT NULL,
	update_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE injuredsegments (
	id bigserial NOT NULL,
	info bytea NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE irreparabledbs (
	segmentpath bytea NOT NULL,
	segmentdetail bytea NOT NULL,
	pieces_lost_count bigint NOT NULL,
	seg_damaged_unix_sec bigint NOT NULL,
	repair_attempt_count bigint NOT NULL,
	PRIMARY KEY ( segmentpath )
);
CREATE TABLE nodes (
	id bytea NOT NULL,
	address text NOT NULL,
	protocol integer NOT NULL,
	type integer NOT NULL,
	email text NOT NULL,
	wallet text NOT NULL,
	free_bandwidth bigint NOT NULL,
	free_disk bigint NOT NULL,
	latency_90 bigint NOT NULL,
	audit_success_count bigint NOT NULL,
	total_audit_count bigint NOT NULL,
	audit_success_ratio double precision NOT NULL,
	uptime_success_count bigint NOT NULL,
	total_uptime_count bigint NOT NULL,
	uptime_ratio double precision NOT NULL,
	created_at timestamp with time zone NOT NULL,
	updated_at timestamp with time zone NOT NULL,
	last_contact_success timestamp with time zone NOT NULL,
	last_contact_failure timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE projects (
	id bytea NOT NULL,
	name text NOT NULL,
	description text NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE registration_tokens (
	secret bytea NOT NULL,
	owner_id bytea,
	project_limit integer NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( secret ),
	UNIQUE ( owner_id )
);
CREATE TABLE serial_numbers (
	id serial NOT NULL,
	serial_number bytea NOT NULL,
	bucket_id bytea NOT NULL,
	expires_at timestamp NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE storagenode_bandwidth_rollups (
	storagenode_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	interval_seconds integer NOT NULL,
	action integer NOT NULL,
	allocated bigint NOT NULL,
	settled bigint NOT NULL,
	PRIMARY KEY ( storagenode_id, interval_start, action )
);
CREATE TABLE storagenode_storage_tallies (
	storagenode_id bytea NOT NULL,
	interval_start timestamp NOT NULL,
	total bigint NOT NULL,
	PRIMARY KEY ( storagenode_id, interval_start )
);
CREATE TABLE users (
	id bytea NOT NULL,
	full_name text NOT NULL,
	short_name text,
	email text NOT NULL,
	password_hash bytea NOT NULL,
	status integer NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE api_keys (
	id bytea NOT NULL,
	project_id bytea NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	key bytea NOT NULL,
	name text NOT NULL,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( id ),
	UNIQUE ( key ),
	UNIQUE ( name, project_id )
);
CREATE TABLE project_members (
	member_id bytea NOT NULL REFERENCES users( id ) ON DELETE CASCADE,
	project_id bytea NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	created_at timestamp with time zone NOT NULL,
	PRIMARY KEY ( member_id, project_id )
);
CREATE TABLE used_serials (
	serial_number_id integer NOT NULL REFERENCES serial_numbers( id ) ON DELETE CASCADE,
	storage_node_id bytea NOT NULL,
	PRIMARY KEY ( serial_number_id, storage_node_id )
);
CREATE INDEX bucket_id_interval_start_interval_seconds ON bucket_bandwidth_rollups ( bucket_id, interval_start, interval_seconds );
CREATE UNIQUE INDEX bucket_id_rollup ON bucket_usages ( bucket_id, rollup_end_time );
CREATE UNIQUE INDEX serial_number ON serial_numbers ( serial_number );
CREATE INDEX serial_numbers_expires_at_index ON serial_numbers ( expires_at );
CREATE INDEX storagenode_id_interval_start_interval_seconds ON storagenode_bandwidth_rollups ( storagenode_id, interval_start, interval_seconds );`
}

func (obj *postgresDB) wrapTx(tx *sql.Tx) txMethods {
	return &postgresTx{
		dialectTx: dialectTx{tx: tx},
		postgresImpl: &postgresImpl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type postgresTx struct {
	dialectTx
	*postgresImpl
}

func postgresLogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type sqlite3Impl struct {
	db      *DB
	dialect __sqlbundle_sqlite3
	driver  driver
}

func (obj *sqlite3Impl) Rebind(s string) string {
	return obj.dialect.Rebind(s)
}

func (obj *sqlite3Impl) logStmt(stmt string, args ...interface{}) {
	sqlite3LogStmt(stmt, args...)
}

func (obj *sqlite3Impl) makeErr(err error) error {
	constraint, ok := obj.isConstraintError(err)
	if ok {
		return constraintViolation(err, constraint)
	}
	return makeErr(err)
}

type sqlite3DB struct {
	db *DB
	*sqlite3Impl
}

func newsqlite3(db *DB) *sqlite3DB {
	return &sqlite3DB{
		db: db,
		sqlite3Impl: &sqlite3Impl{
			db:     db,
			driver: db.DB,
		},
	}
}

func (obj *sqlite3DB) Schema() string {
	return `CREATE TABLE accounting_raws (
	id INTEGER NOT NULL,
	node_id BLOB NOT NULL,
	interval_end_time TIMESTAMP NOT NULL,
	data_total REAL NOT NULL,
	data_type INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE accounting_rollups (
	id INTEGER NOT NULL,
	node_id BLOB NOT NULL,
	start_time TIMESTAMP NOT NULL,
	put_total INTEGER NOT NULL,
	get_total INTEGER NOT NULL,
	get_audit_total INTEGER NOT NULL,
	get_repair_total INTEGER NOT NULL,
	put_repair_total INTEGER NOT NULL,
	at_rest_total REAL NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE accounting_timestamps (
	name TEXT NOT NULL,
	value TIMESTAMP NOT NULL,
	PRIMARY KEY ( name )
);
CREATE TABLE bucket_bandwidth_rollups (
	bucket_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	interval_seconds INTEGER NOT NULL,
	action INTEGER NOT NULL,
	inline INTEGER NOT NULL,
	allocated INTEGER NOT NULL,
	settled INTEGER NOT NULL,
	PRIMARY KEY ( bucket_id, interval_start, action )
);
CREATE TABLE bucket_storage_tallies (
	bucket_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	inline INTEGER NOT NULL,
	remote INTEGER NOT NULL,
	remote_segments_count INTEGER NOT NULL,
	inline_segments_count INTEGER NOT NULL,
	object_count INTEGER NOT NULL,
	metadata_size INTEGER NOT NULL,
	PRIMARY KEY ( bucket_id, interval_start )
);
CREATE TABLE bucket_usages (
	id BLOB NOT NULL,
	bucket_id BLOB NOT NULL,
	rollup_end_time TIMESTAMP NOT NULL,
	remote_stored_data INTEGER NOT NULL,
	inline_stored_data INTEGER NOT NULL,
	remote_segments INTEGER NOT NULL,
	inline_segments INTEGER NOT NULL,
	objects INTEGER NOT NULL,
	metadata_size INTEGER NOT NULL,
	repair_egress INTEGER NOT NULL,
	get_egress INTEGER NOT NULL,
	audit_egress INTEGER NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE bwagreements (
	serialnum TEXT NOT NULL,
	storage_node_id BLOB NOT NULL,
	uplink_id BLOB NOT NULL,
	action INTEGER NOT NULL,
	total INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	expires_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( serialnum )
);
CREATE TABLE certRecords (
	publickey BLOB NOT NULL,
	id BLOB NOT NULL,
	update_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE injuredsegments (
	id INTEGER NOT NULL,
	info BLOB NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE irreparabledbs (
	segmentpath BLOB NOT NULL,
	segmentdetail BLOB NOT NULL,
	pieces_lost_count INTEGER NOT NULL,
	seg_damaged_unix_sec INTEGER NOT NULL,
	repair_attempt_count INTEGER NOT NULL,
	PRIMARY KEY ( segmentpath )
);
CREATE TABLE nodes (
	id BLOB NOT NULL,
	address TEXT NOT NULL,
	protocol INTEGER NOT NULL,
	type INTEGER NOT NULL,
	email TEXT NOT NULL,
	wallet TEXT NOT NULL,
	free_bandwidth INTEGER NOT NULL,
	free_disk INTEGER NOT NULL,
	latency_90 INTEGER NOT NULL,
	audit_success_count INTEGER NOT NULL,
	total_audit_count INTEGER NOT NULL,
	audit_success_ratio REAL NOT NULL,
	uptime_success_count INTEGER NOT NULL,
	total_uptime_count INTEGER NOT NULL,
	uptime_ratio REAL NOT NULL,
	created_at TIMESTAMP NOT NULL,
	updated_at TIMESTAMP NOT NULL,
	last_contact_success TIMESTAMP NOT NULL,
	last_contact_failure TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE projects (
	id BLOB NOT NULL,
	name TEXT NOT NULL,
	description TEXT NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE registration_tokens (
	secret BLOB NOT NULL,
	owner_id BLOB,
	project_limit INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( secret ),
	UNIQUE ( owner_id )
);
CREATE TABLE serial_numbers (
	id INTEGER NOT NULL,
	serial_number BLOB NOT NULL,
	bucket_id BLOB NOT NULL,
	expires_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE storagenode_bandwidth_rollups (
	storagenode_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	interval_seconds INTEGER NOT NULL,
	action INTEGER NOT NULL,
	allocated INTEGER NOT NULL,
	settled INTEGER NOT NULL,
	PRIMARY KEY ( storagenode_id, interval_start, action )
);
CREATE TABLE storagenode_storage_tallies (
	storagenode_id BLOB NOT NULL,
	interval_start TIMESTAMP NOT NULL,
	total INTEGER NOT NULL,
	PRIMARY KEY ( storagenode_id, interval_start )
);
CREATE TABLE users (
	id BLOB NOT NULL,
	full_name TEXT NOT NULL,
	short_name TEXT,
	email TEXT NOT NULL,
	password_hash BLOB NOT NULL,
	status INTEGER NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id )
);
CREATE TABLE api_keys (
	id BLOB NOT NULL,
	project_id BLOB NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	key BLOB NOT NULL,
	name TEXT NOT NULL,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( id ),
	UNIQUE ( key ),
	UNIQUE ( name, project_id )
);
CREATE TABLE project_members (
	member_id BLOB NOT NULL REFERENCES users( id ) ON DELETE CASCADE,
	project_id BLOB NOT NULL REFERENCES projects( id ) ON DELETE CASCADE,
	created_at TIMESTAMP NOT NULL,
	PRIMARY KEY ( member_id, project_id )
);
CREATE TABLE used_serials (
	serial_number_id INTEGER NOT NULL REFERENCES serial_numbers( id ) ON DELETE CASCADE,
	storage_node_id BLOB NOT NULL,
	PRIMARY KEY ( serial_number_id, storage_node_id )
);
CREATE INDEX bucket_id_interval_start_interval_seconds ON bucket_bandwidth_rollups ( bucket_id, interval_start, interval_seconds );
CREATE UNIQUE INDEX bucket_id_rollup ON bucket_usages ( bucket_id, rollup_end_time );
CREATE UNIQUE INDEX serial_number ON serial_numbers ( serial_number );
CREATE INDEX serial_numbers_expires_at_index ON serial_numbers ( expires_at );
CREATE INDEX storagenode_id_interval_start_interval_seconds ON storagenode_bandwidth_rollups ( storagenode_id, interval_start, interval_seconds );`
}

func (obj *sqlite3DB) wrapTx(tx *sql.Tx) txMethods {
	return &sqlite3Tx{
		dialectTx: dialectTx{tx: tx},
		sqlite3Impl: &sqlite3Impl{
			db:     obj.db,
			driver: tx,
		},
	}
}

type sqlite3Tx struct {
	dialectTx
	*sqlite3Impl
}

func sqlite3LogStmt(stmt string, args ...interface{}) {
	// TODO: render placeholders
	if Logger != nil {
		out := fmt.Sprintf("stmt: %s\nargs: %v\n", stmt, pretty(args))
		Logger(out)
	}
}

type pretty []interface{}

func (p pretty) Format(f fmt.State, c rune) {
	fmt.Fprint(f, "[")
nextval:
	for i, val := range p {
		if i > 0 {
			fmt.Fprint(f, ", ")
		}
		rv := reflect.ValueOf(val)
		if rv.Kind() == reflect.Ptr {
			if rv.IsNil() {
				fmt.Fprint(f, "NULL")
				continue
			}
			val = rv.Elem().Interface()
		}
		switch v := val.(type) {
		case string:
			fmt.Fprintf(f, "%q", v)
		case time.Time:
			fmt.Fprintf(f, "%s", v.Format(time.RFC3339Nano))
		case []byte:
			for _, b := range v {
				if !unicode.IsPrint(rune(b)) {
					fmt.Fprintf(f, "%#x", v)
					continue nextval
				}
			}
			fmt.Fprintf(f, "%q", v)
		default:
			fmt.Fprintf(f, "%v", v)
		}
	}
	fmt.Fprint(f, "]")
}

type AccountingRaw struct {
	Id              int64
	NodeId          []byte
	IntervalEndTime time.Time
	DataTotal       float64
	DataType        int
	CreatedAt       time.Time
}

func (AccountingRaw) _Table() string { return "accounting_raws" }

type AccountingRaw_Update_Fields struct {
}

type AccountingRaw_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRaw_Id(v int64) AccountingRaw_Id_Field {
	return AccountingRaw_Id_Field{_set: true, _value: v}
}

func (f AccountingRaw_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRaw_Id_Field) _Column() string { return "id" }

type AccountingRaw_NodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func AccountingRaw_NodeId(v []byte) AccountingRaw_NodeId_Field {
	return AccountingRaw_NodeId_Field{_set: true, _value: v}
}

func (f AccountingRaw_NodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRaw_NodeId_Field) _Column() string { return "node_id" }

type AccountingRaw_IntervalEndTime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func AccountingRaw_IntervalEndTime(v time.Time) AccountingRaw_IntervalEndTime_Field {
	return AccountingRaw_IntervalEndTime_Field{_set: true, _value: v}
}

func (f AccountingRaw_IntervalEndTime_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRaw_IntervalEndTime_Field) _Column() string { return "interval_end_time" }

type AccountingRaw_DataTotal_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func AccountingRaw_DataTotal(v float64) AccountingRaw_DataTotal_Field {
	return AccountingRaw_DataTotal_Field{_set: true, _value: v}
}

func (f AccountingRaw_DataTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRaw_DataTotal_Field) _Column() string { return "data_total" }

type AccountingRaw_DataType_Field struct {
	_set   bool
	_null  bool
	_value int
}

func AccountingRaw_DataType(v int) AccountingRaw_DataType_Field {
	return AccountingRaw_DataType_Field{_set: true, _value: v}
}

func (f AccountingRaw_DataType_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRaw_DataType_Field) _Column() string { return "data_type" }

type AccountingRaw_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func AccountingRaw_CreatedAt(v time.Time) AccountingRaw_CreatedAt_Field {
	return AccountingRaw_CreatedAt_Field{_set: true, _value: v}
}

func (f AccountingRaw_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRaw_CreatedAt_Field) _Column() string { return "created_at" }

type AccountingRollup struct {
	Id             int64
	NodeId         []byte
	StartTime      time.Time
	PutTotal       int64
	GetTotal       int64
	GetAuditTotal  int64
	GetRepairTotal int64
	PutRepairTotal int64
	AtRestTotal    float64
}

func (AccountingRollup) _Table() string { return "accounting_rollups" }

type AccountingRollup_Update_Fields struct {
}

type AccountingRollup_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_Id(v int64) AccountingRollup_Id_Field {
	return AccountingRollup_Id_Field{_set: true, _value: v}
}

func (f AccountingRollup_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_Id_Field) _Column() string { return "id" }

type AccountingRollup_NodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func AccountingRollup_NodeId(v []byte) AccountingRollup_NodeId_Field {
	return AccountingRollup_NodeId_Field{_set: true, _value: v}
}

func (f AccountingRollup_NodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_NodeId_Field) _Column() string { return "node_id" }

type AccountingRollup_StartTime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func AccountingRollup_StartTime(v time.Time) AccountingRollup_StartTime_Field {
	return AccountingRollup_StartTime_Field{_set: true, _value: v}
}

func (f AccountingRollup_StartTime_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_StartTime_Field) _Column() string { return "start_time" }

type AccountingRollup_PutTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_PutTotal(v int64) AccountingRollup_PutTotal_Field {
	return AccountingRollup_PutTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_PutTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_PutTotal_Field) _Column() string { return "put_total" }

type AccountingRollup_GetTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_GetTotal(v int64) AccountingRollup_GetTotal_Field {
	return AccountingRollup_GetTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_GetTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_GetTotal_Field) _Column() string { return "get_total" }

type AccountingRollup_GetAuditTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_GetAuditTotal(v int64) AccountingRollup_GetAuditTotal_Field {
	return AccountingRollup_GetAuditTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_GetAuditTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_GetAuditTotal_Field) _Column() string { return "get_audit_total" }

type AccountingRollup_GetRepairTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_GetRepairTotal(v int64) AccountingRollup_GetRepairTotal_Field {
	return AccountingRollup_GetRepairTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_GetRepairTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_GetRepairTotal_Field) _Column() string { return "get_repair_total" }

type AccountingRollup_PutRepairTotal_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func AccountingRollup_PutRepairTotal(v int64) AccountingRollup_PutRepairTotal_Field {
	return AccountingRollup_PutRepairTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_PutRepairTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_PutRepairTotal_Field) _Column() string { return "put_repair_total" }

type AccountingRollup_AtRestTotal_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func AccountingRollup_AtRestTotal(v float64) AccountingRollup_AtRestTotal_Field {
	return AccountingRollup_AtRestTotal_Field{_set: true, _value: v}
}

func (f AccountingRollup_AtRestTotal_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingRollup_AtRestTotal_Field) _Column() string { return "at_rest_total" }

type AccountingTimestamps struct {
	Name  string
	Value time.Time
}

func (AccountingTimestamps) _Table() string { return "accounting_timestamps" }

type AccountingTimestamps_Update_Fields struct {
	Value AccountingTimestamps_Value_Field
}

type AccountingTimestamps_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func AccountingTimestamps_Name(v string) AccountingTimestamps_Name_Field {
	return AccountingTimestamps_Name_Field{_set: true, _value: v}
}

func (f AccountingTimestamps_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingTimestamps_Name_Field) _Column() string { return "name" }

type AccountingTimestamps_Value_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func AccountingTimestamps_Value(v time.Time) AccountingTimestamps_Value_Field {
	return AccountingTimestamps_Value_Field{_set: true, _value: v}
}

func (f AccountingTimestamps_Value_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (AccountingTimestamps_Value_Field) _Column() string { return "value" }

type BucketBandwidthRollup struct {
	BucketId        []byte
	IntervalStart   time.Time
	IntervalSeconds uint
	Action          uint
	Inline          uint64
	Allocated       uint64
	Settled         uint64
}

func (BucketBandwidthRollup) _Table() string { return "bucket_bandwidth_rollups" }

type BucketBandwidthRollup_Update_Fields struct {
}

type BucketBandwidthRollup_BucketId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketBandwidthRollup_BucketId(v []byte) BucketBandwidthRollup_BucketId_Field {
	return BucketBandwidthRollup_BucketId_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_BucketId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_BucketId_Field) _Column() string { return "bucket_id" }

type BucketBandwidthRollup_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketBandwidthRollup_IntervalStart(v time.Time) BucketBandwidthRollup_IntervalStart_Field {
	v = toUTC(v)
	return BucketBandwidthRollup_IntervalStart_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_IntervalStart_Field) _Column() string { return "interval_start" }

type BucketBandwidthRollup_IntervalSeconds_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketBandwidthRollup_IntervalSeconds(v uint) BucketBandwidthRollup_IntervalSeconds_Field {
	return BucketBandwidthRollup_IntervalSeconds_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_IntervalSeconds_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_IntervalSeconds_Field) _Column() string { return "interval_seconds" }

type BucketBandwidthRollup_Action_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketBandwidthRollup_Action(v uint) BucketBandwidthRollup_Action_Field {
	return BucketBandwidthRollup_Action_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Action_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Action_Field) _Column() string { return "action" }

type BucketBandwidthRollup_Inline_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketBandwidthRollup_Inline(v uint64) BucketBandwidthRollup_Inline_Field {
	return BucketBandwidthRollup_Inline_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Inline_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Inline_Field) _Column() string { return "inline" }

type BucketBandwidthRollup_Allocated_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketBandwidthRollup_Allocated(v uint64) BucketBandwidthRollup_Allocated_Field {
	return BucketBandwidthRollup_Allocated_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Allocated_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Allocated_Field) _Column() string { return "allocated" }

type BucketBandwidthRollup_Settled_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketBandwidthRollup_Settled(v uint64) BucketBandwidthRollup_Settled_Field {
	return BucketBandwidthRollup_Settled_Field{_set: true, _value: v}
}

func (f BucketBandwidthRollup_Settled_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketBandwidthRollup_Settled_Field) _Column() string { return "settled" }

type BucketStorageTally struct {
	BucketId            []byte
	IntervalStart       time.Time
	Inline              uint64
	Remote              uint64
	RemoteSegmentsCount uint
	InlineSegmentsCount uint
	ObjectCount         uint
	MetadataSize        uint64
}

func (BucketStorageTally) _Table() string { return "bucket_storage_tallies" }

type BucketStorageTally_Update_Fields struct {
}

type BucketStorageTally_BucketId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketStorageTally_BucketId(v []byte) BucketStorageTally_BucketId_Field {
	return BucketStorageTally_BucketId_Field{_set: true, _value: v}
}

func (f BucketStorageTally_BucketId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_BucketId_Field) _Column() string { return "bucket_id" }

type BucketStorageTally_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketStorageTally_IntervalStart(v time.Time) BucketStorageTally_IntervalStart_Field {
	v = toUTC(v)
	return BucketStorageTally_IntervalStart_Field{_set: true, _value: v}
}

func (f BucketStorageTally_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_IntervalStart_Field) _Column() string { return "interval_start" }

type BucketStorageTally_Inline_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketStorageTally_Inline(v uint64) BucketStorageTally_Inline_Field {
	return BucketStorageTally_Inline_Field{_set: true, _value: v}
}

func (f BucketStorageTally_Inline_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_Inline_Field) _Column() string { return "inline" }

type BucketStorageTally_Remote_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketStorageTally_Remote(v uint64) BucketStorageTally_Remote_Field {
	return BucketStorageTally_Remote_Field{_set: true, _value: v}
}

func (f BucketStorageTally_Remote_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_Remote_Field) _Column() string { return "remote" }

type BucketStorageTally_RemoteSegmentsCount_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketStorageTally_RemoteSegmentsCount(v uint) BucketStorageTally_RemoteSegmentsCount_Field {
	return BucketStorageTally_RemoteSegmentsCount_Field{_set: true, _value: v}
}

func (f BucketStorageTally_RemoteSegmentsCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_RemoteSegmentsCount_Field) _Column() string { return "remote_segments_count" }

type BucketStorageTally_InlineSegmentsCount_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketStorageTally_InlineSegmentsCount(v uint) BucketStorageTally_InlineSegmentsCount_Field {
	return BucketStorageTally_InlineSegmentsCount_Field{_set: true, _value: v}
}

func (f BucketStorageTally_InlineSegmentsCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_InlineSegmentsCount_Field) _Column() string { return "inline_segments_count" }

type BucketStorageTally_ObjectCount_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketStorageTally_ObjectCount(v uint) BucketStorageTally_ObjectCount_Field {
	return BucketStorageTally_ObjectCount_Field{_set: true, _value: v}
}

func (f BucketStorageTally_ObjectCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_ObjectCount_Field) _Column() string { return "object_count" }

type BucketStorageTally_MetadataSize_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketStorageTally_MetadataSize(v uint64) BucketStorageTally_MetadataSize_Field {
	return BucketStorageTally_MetadataSize_Field{_set: true, _value: v}
}

func (f BucketStorageTally_MetadataSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketStorageTally_MetadataSize_Field) _Column() string { return "metadata_size" }

type BucketUsage struct {
	Id               []byte
	BucketId         []byte
	RollupEndTime    time.Time
	RemoteStoredData uint64
	InlineStoredData uint64
	RemoteSegments   uint
	InlineSegments   uint
	Objects          uint
	MetadataSize     uint64
	RepairEgress     uint64
	GetEgress        uint64
	AuditEgress      uint64
}

func (BucketUsage) _Table() string { return "bucket_usages" }

type BucketUsage_Update_Fields struct {
}

type BucketUsage_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketUsage_Id(v []byte) BucketUsage_Id_Field {
	return BucketUsage_Id_Field{_set: true, _value: v}
}

func (f BucketUsage_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_Id_Field) _Column() string { return "id" }

type BucketUsage_BucketId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func BucketUsage_BucketId(v []byte) BucketUsage_BucketId_Field {
	return BucketUsage_BucketId_Field{_set: true, _value: v}
}

func (f BucketUsage_BucketId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_BucketId_Field) _Column() string { return "bucket_id" }

type BucketUsage_RollupEndTime_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func BucketUsage_RollupEndTime(v time.Time) BucketUsage_RollupEndTime_Field {
	return BucketUsage_RollupEndTime_Field{_set: true, _value: v}
}

func (f BucketUsage_RollupEndTime_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RollupEndTime_Field) _Column() string { return "rollup_end_time" }

type BucketUsage_RemoteStoredData_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_RemoteStoredData(v uint64) BucketUsage_RemoteStoredData_Field {
	return BucketUsage_RemoteStoredData_Field{_set: true, _value: v}
}

func (f BucketUsage_RemoteStoredData_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RemoteStoredData_Field) _Column() string { return "remote_stored_data" }

type BucketUsage_InlineStoredData_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_InlineStoredData(v uint64) BucketUsage_InlineStoredData_Field {
	return BucketUsage_InlineStoredData_Field{_set: true, _value: v}
}

func (f BucketUsage_InlineStoredData_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_InlineStoredData_Field) _Column() string { return "inline_stored_data" }

type BucketUsage_RemoteSegments_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketUsage_RemoteSegments(v uint) BucketUsage_RemoteSegments_Field {
	return BucketUsage_RemoteSegments_Field{_set: true, _value: v}
}

func (f BucketUsage_RemoteSegments_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RemoteSegments_Field) _Column() string { return "remote_segments" }

type BucketUsage_InlineSegments_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketUsage_InlineSegments(v uint) BucketUsage_InlineSegments_Field {
	return BucketUsage_InlineSegments_Field{_set: true, _value: v}
}

func (f BucketUsage_InlineSegments_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_InlineSegments_Field) _Column() string { return "inline_segments" }

type BucketUsage_Objects_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func BucketUsage_Objects(v uint) BucketUsage_Objects_Field {
	return BucketUsage_Objects_Field{_set: true, _value: v}
}

func (f BucketUsage_Objects_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_Objects_Field) _Column() string { return "objects" }

type BucketUsage_MetadataSize_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_MetadataSize(v uint64) BucketUsage_MetadataSize_Field {
	return BucketUsage_MetadataSize_Field{_set: true, _value: v}
}

func (f BucketUsage_MetadataSize_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_MetadataSize_Field) _Column() string { return "metadata_size" }

type BucketUsage_RepairEgress_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_RepairEgress(v uint64) BucketUsage_RepairEgress_Field {
	return BucketUsage_RepairEgress_Field{_set: true, _value: v}
}

func (f BucketUsage_RepairEgress_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_RepairEgress_Field) _Column() string { return "repair_egress" }

type BucketUsage_GetEgress_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_GetEgress(v uint64) BucketUsage_GetEgress_Field {
	return BucketUsage_GetEgress_Field{_set: true, _value: v}
}

func (f BucketUsage_GetEgress_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_GetEgress_Field) _Column() string { return "get_egress" }

type BucketUsage_AuditEgress_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func BucketUsage_AuditEgress(v uint64) BucketUsage_AuditEgress_Field {
	return BucketUsage_AuditEgress_Field{_set: true, _value: v}
}

func (f BucketUsage_AuditEgress_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (BucketUsage_AuditEgress_Field) _Column() string { return "audit_egress" }

type Bwagreement struct {
	Serialnum     string
	StorageNodeId []byte
	UplinkId      []byte
	Action        int64
	Total         int64
	CreatedAt     time.Time
	ExpiresAt     time.Time
}

func (Bwagreement) _Table() string { return "bwagreements" }

type Bwagreement_Update_Fields struct {
}

type Bwagreement_Serialnum_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Bwagreement_Serialnum(v string) Bwagreement_Serialnum_Field {
	return Bwagreement_Serialnum_Field{_set: true, _value: v}
}

func (f Bwagreement_Serialnum_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_Serialnum_Field) _Column() string { return "serialnum" }

type Bwagreement_StorageNodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Bwagreement_StorageNodeId(v []byte) Bwagreement_StorageNodeId_Field {
	return Bwagreement_StorageNodeId_Field{_set: true, _value: v}
}

func (f Bwagreement_StorageNodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_StorageNodeId_Field) _Column() string { return "storage_node_id" }

type Bwagreement_UplinkId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Bwagreement_UplinkId(v []byte) Bwagreement_UplinkId_Field {
	return Bwagreement_UplinkId_Field{_set: true, _value: v}
}

func (f Bwagreement_UplinkId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_UplinkId_Field) _Column() string { return "uplink_id" }

type Bwagreement_Action_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Bwagreement_Action(v int64) Bwagreement_Action_Field {
	return Bwagreement_Action_Field{_set: true, _value: v}
}

func (f Bwagreement_Action_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_Action_Field) _Column() string { return "action" }

type Bwagreement_Total_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Bwagreement_Total(v int64) Bwagreement_Total_Field {
	return Bwagreement_Total_Field{_set: true, _value: v}
}

func (f Bwagreement_Total_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_Total_Field) _Column() string { return "total" }

type Bwagreement_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Bwagreement_CreatedAt(v time.Time) Bwagreement_CreatedAt_Field {
	return Bwagreement_CreatedAt_Field{_set: true, _value: v}
}

func (f Bwagreement_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_CreatedAt_Field) _Column() string { return "created_at" }

type Bwagreement_ExpiresAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Bwagreement_ExpiresAt(v time.Time) Bwagreement_ExpiresAt_Field {
	return Bwagreement_ExpiresAt_Field{_set: true, _value: v}
}

func (f Bwagreement_ExpiresAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Bwagreement_ExpiresAt_Field) _Column() string { return "expires_at" }

type CertRecord struct {
	Publickey []byte
	Id        []byte
	UpdateAt  time.Time
}

func (CertRecord) _Table() string { return "certRecords" }

type CertRecord_Update_Fields struct {
}

type CertRecord_Publickey_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func CertRecord_Publickey(v []byte) CertRecord_Publickey_Field {
	return CertRecord_Publickey_Field{_set: true, _value: v}
}

func (f CertRecord_Publickey_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CertRecord_Publickey_Field) _Column() string { return "publickey" }

type CertRecord_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func CertRecord_Id(v []byte) CertRecord_Id_Field {
	return CertRecord_Id_Field{_set: true, _value: v}
}

func (f CertRecord_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CertRecord_Id_Field) _Column() string { return "id" }

type CertRecord_UpdateAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func CertRecord_UpdateAt(v time.Time) CertRecord_UpdateAt_Field {
	return CertRecord_UpdateAt_Field{_set: true, _value: v}
}

func (f CertRecord_UpdateAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (CertRecord_UpdateAt_Field) _Column() string { return "update_at" }

type Injuredsegment struct {
	Id   int64
	Info []byte
}

func (Injuredsegment) _Table() string { return "injuredsegments" }

type Injuredsegment_Update_Fields struct {
}

type Injuredsegment_Id_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Injuredsegment_Id(v int64) Injuredsegment_Id_Field {
	return Injuredsegment_Id_Field{_set: true, _value: v}
}

func (f Injuredsegment_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Injuredsegment_Id_Field) _Column() string { return "id" }

type Injuredsegment_Info_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Injuredsegment_Info(v []byte) Injuredsegment_Info_Field {
	return Injuredsegment_Info_Field{_set: true, _value: v}
}

func (f Injuredsegment_Info_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Injuredsegment_Info_Field) _Column() string { return "info" }

type Irreparabledb struct {
	Segmentpath        []byte
	Segmentdetail      []byte
	PiecesLostCount    int64
	SegDamagedUnixSec  int64
	RepairAttemptCount int64
}

func (Irreparabledb) _Table() string { return "irreparabledbs" }

type Irreparabledb_Update_Fields struct {
	Segmentdetail      Irreparabledb_Segmentdetail_Field
	PiecesLostCount    Irreparabledb_PiecesLostCount_Field
	SegDamagedUnixSec  Irreparabledb_SegDamagedUnixSec_Field
	RepairAttemptCount Irreparabledb_RepairAttemptCount_Field
}

type Irreparabledb_Segmentpath_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Irreparabledb_Segmentpath(v []byte) Irreparabledb_Segmentpath_Field {
	return Irreparabledb_Segmentpath_Field{_set: true, _value: v}
}

func (f Irreparabledb_Segmentpath_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_Segmentpath_Field) _Column() string { return "segmentpath" }

type Irreparabledb_Segmentdetail_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Irreparabledb_Segmentdetail(v []byte) Irreparabledb_Segmentdetail_Field {
	return Irreparabledb_Segmentdetail_Field{_set: true, _value: v}
}

func (f Irreparabledb_Segmentdetail_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_Segmentdetail_Field) _Column() string { return "segmentdetail" }

type Irreparabledb_PiecesLostCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Irreparabledb_PiecesLostCount(v int64) Irreparabledb_PiecesLostCount_Field {
	return Irreparabledb_PiecesLostCount_Field{_set: true, _value: v}
}

func (f Irreparabledb_PiecesLostCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_PiecesLostCount_Field) _Column() string { return "pieces_lost_count" }

type Irreparabledb_SegDamagedUnixSec_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Irreparabledb_SegDamagedUnixSec(v int64) Irreparabledb_SegDamagedUnixSec_Field {
	return Irreparabledb_SegDamagedUnixSec_Field{_set: true, _value: v}
}

func (f Irreparabledb_SegDamagedUnixSec_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_SegDamagedUnixSec_Field) _Column() string { return "seg_damaged_unix_sec" }

type Irreparabledb_RepairAttemptCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Irreparabledb_RepairAttemptCount(v int64) Irreparabledb_RepairAttemptCount_Field {
	return Irreparabledb_RepairAttemptCount_Field{_set: true, _value: v}
}

func (f Irreparabledb_RepairAttemptCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Irreparabledb_RepairAttemptCount_Field) _Column() string { return "repair_attempt_count" }

type Node struct {
	Id                 []byte
	Address            string
	Protocol           int
	Type               int
	Email              string
	Wallet             string
	FreeBandwidth      int64
	FreeDisk           int64
	Latency90          int64
	AuditSuccessCount  int64
	TotalAuditCount    int64
	AuditSuccessRatio  float64
	UptimeSuccessCount int64
	TotalUptimeCount   int64
	UptimeRatio        float64
	CreatedAt          time.Time
	UpdatedAt          time.Time
	LastContactSuccess time.Time
	LastContactFailure time.Time
}

func (Node) _Table() string { return "nodes" }

type Node_Update_Fields struct {
	Address            Node_Address_Field
	Protocol           Node_Protocol_Field
	Type               Node_Type_Field
	Email              Node_Email_Field
	Wallet             Node_Wallet_Field
	FreeBandwidth      Node_FreeBandwidth_Field
	FreeDisk           Node_FreeDisk_Field
	Latency90          Node_Latency90_Field
	AuditSuccessCount  Node_AuditSuccessCount_Field
	TotalAuditCount    Node_TotalAuditCount_Field
	AuditSuccessRatio  Node_AuditSuccessRatio_Field
	UptimeSuccessCount Node_UptimeSuccessCount_Field
	TotalUptimeCount   Node_TotalUptimeCount_Field
	UptimeRatio        Node_UptimeRatio_Field
	LastContactSuccess Node_LastContactSuccess_Field
	LastContactFailure Node_LastContactFailure_Field
}

type Node_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Node_Id(v []byte) Node_Id_Field {
	return Node_Id_Field{_set: true, _value: v}
}

func (f Node_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Id_Field) _Column() string { return "id" }

type Node_Address_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Address(v string) Node_Address_Field {
	return Node_Address_Field{_set: true, _value: v}
}

func (f Node_Address_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Address_Field) _Column() string { return "address" }

type Node_Protocol_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Node_Protocol(v int) Node_Protocol_Field {
	return Node_Protocol_Field{_set: true, _value: v}
}

func (f Node_Protocol_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Protocol_Field) _Column() string { return "protocol" }

type Node_Type_Field struct {
	_set   bool
	_null  bool
	_value int
}

func Node_Type(v int) Node_Type_Field {
	return Node_Type_Field{_set: true, _value: v}
}

func (f Node_Type_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Type_Field) _Column() string { return "type" }

type Node_Email_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Email(v string) Node_Email_Field {
	return Node_Email_Field{_set: true, _value: v}
}

func (f Node_Email_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Email_Field) _Column() string { return "email" }

type Node_Wallet_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Node_Wallet(v string) Node_Wallet_Field {
	return Node_Wallet_Field{_set: true, _value: v}
}

func (f Node_Wallet_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Wallet_Field) _Column() string { return "wallet" }

type Node_FreeBandwidth_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_FreeBandwidth(v int64) Node_FreeBandwidth_Field {
	return Node_FreeBandwidth_Field{_set: true, _value: v}
}

func (f Node_FreeBandwidth_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_FreeBandwidth_Field) _Column() string { return "free_bandwidth" }

type Node_FreeDisk_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_FreeDisk(v int64) Node_FreeDisk_Field {
	return Node_FreeDisk_Field{_set: true, _value: v}
}

func (f Node_FreeDisk_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_FreeDisk_Field) _Column() string { return "free_disk" }

type Node_Latency90_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_Latency90(v int64) Node_Latency90_Field {
	return Node_Latency90_Field{_set: true, _value: v}
}

func (f Node_Latency90_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_Latency90_Field) _Column() string { return "latency_90" }

type Node_AuditSuccessCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_AuditSuccessCount(v int64) Node_AuditSuccessCount_Field {
	return Node_AuditSuccessCount_Field{_set: true, _value: v}
}

func (f Node_AuditSuccessCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_AuditSuccessCount_Field) _Column() string { return "audit_success_count" }

type Node_TotalAuditCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_TotalAuditCount(v int64) Node_TotalAuditCount_Field {
	return Node_TotalAuditCount_Field{_set: true, _value: v}
}

func (f Node_TotalAuditCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_TotalAuditCount_Field) _Column() string { return "total_audit_count" }

type Node_AuditSuccessRatio_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Node_AuditSuccessRatio(v float64) Node_AuditSuccessRatio_Field {
	return Node_AuditSuccessRatio_Field{_set: true, _value: v}
}

func (f Node_AuditSuccessRatio_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_AuditSuccessRatio_Field) _Column() string { return "audit_success_ratio" }

type Node_UptimeSuccessCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_UptimeSuccessCount(v int64) Node_UptimeSuccessCount_Field {
	return Node_UptimeSuccessCount_Field{_set: true, _value: v}
}

func (f Node_UptimeSuccessCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UptimeSuccessCount_Field) _Column() string { return "uptime_success_count" }

type Node_TotalUptimeCount_Field struct {
	_set   bool
	_null  bool
	_value int64
}

func Node_TotalUptimeCount(v int64) Node_TotalUptimeCount_Field {
	return Node_TotalUptimeCount_Field{_set: true, _value: v}
}

func (f Node_TotalUptimeCount_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_TotalUptimeCount_Field) _Column() string { return "total_uptime_count" }

type Node_UptimeRatio_Field struct {
	_set   bool
	_null  bool
	_value float64
}

func Node_UptimeRatio(v float64) Node_UptimeRatio_Field {
	return Node_UptimeRatio_Field{_set: true, _value: v}
}

func (f Node_UptimeRatio_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UptimeRatio_Field) _Column() string { return "uptime_ratio" }

type Node_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_CreatedAt(v time.Time) Node_CreatedAt_Field {
	return Node_CreatedAt_Field{_set: true, _value: v}
}

func (f Node_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_CreatedAt_Field) _Column() string { return "created_at" }

type Node_UpdatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_UpdatedAt(v time.Time) Node_UpdatedAt_Field {
	return Node_UpdatedAt_Field{_set: true, _value: v}
}

func (f Node_UpdatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_UpdatedAt_Field) _Column() string { return "updated_at" }

type Node_LastContactSuccess_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_LastContactSuccess(v time.Time) Node_LastContactSuccess_Field {
	return Node_LastContactSuccess_Field{_set: true, _value: v}
}

func (f Node_LastContactSuccess_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_LastContactSuccess_Field) _Column() string { return "last_contact_success" }

type Node_LastContactFailure_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Node_LastContactFailure(v time.Time) Node_LastContactFailure_Field {
	return Node_LastContactFailure_Field{_set: true, _value: v}
}

func (f Node_LastContactFailure_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Node_LastContactFailure_Field) _Column() string { return "last_contact_failure" }

type Project struct {
	Id          []byte
	Name        string
	Description string
	CreatedAt   time.Time
}

func (Project) _Table() string { return "projects" }

type Project_Update_Fields struct {
	Description Project_Description_Field
}

type Project_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func Project_Id(v []byte) Project_Id_Field {
	return Project_Id_Field{_set: true, _value: v}
}

func (f Project_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_Id_Field) _Column() string { return "id" }

type Project_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Project_Name(v string) Project_Name_Field {
	return Project_Name_Field{_set: true, _value: v}
}

func (f Project_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_Name_Field) _Column() string { return "name" }

type Project_Description_Field struct {
	_set   bool
	_null  bool
	_value string
}

func Project_Description(v string) Project_Description_Field {
	return Project_Description_Field{_set: true, _value: v}
}

func (f Project_Description_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_Description_Field) _Column() string { return "description" }

type Project_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func Project_CreatedAt(v time.Time) Project_CreatedAt_Field {
	return Project_CreatedAt_Field{_set: true, _value: v}
}

func (f Project_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (Project_CreatedAt_Field) _Column() string { return "created_at" }

type RegistrationToken struct {
	Secret       []byte
	OwnerId      []byte
	ProjectLimit int
	CreatedAt    time.Time
}

func (RegistrationToken) _Table() string { return "registration_tokens" }

type RegistrationToken_Create_Fields struct {
	OwnerId RegistrationToken_OwnerId_Field
}

type RegistrationToken_Update_Fields struct {
	OwnerId RegistrationToken_OwnerId_Field
}

type RegistrationToken_Secret_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func RegistrationToken_Secret(v []byte) RegistrationToken_Secret_Field {
	return RegistrationToken_Secret_Field{_set: true, _value: v}
}

func (f RegistrationToken_Secret_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_Secret_Field) _Column() string { return "secret" }

type RegistrationToken_OwnerId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func RegistrationToken_OwnerId(v []byte) RegistrationToken_OwnerId_Field {
	return RegistrationToken_OwnerId_Field{_set: true, _value: v}
}

func RegistrationToken_OwnerId_Raw(v []byte) RegistrationToken_OwnerId_Field {
	if v == nil {
		return RegistrationToken_OwnerId_Null()
	}
	return RegistrationToken_OwnerId(v)
}

func RegistrationToken_OwnerId_Null() RegistrationToken_OwnerId_Field {
	return RegistrationToken_OwnerId_Field{_set: true, _null: true}
}

func (f RegistrationToken_OwnerId_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f RegistrationToken_OwnerId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_OwnerId_Field) _Column() string { return "owner_id" }

type RegistrationToken_ProjectLimit_Field struct {
	_set   bool
	_null  bool
	_value int
}

func RegistrationToken_ProjectLimit(v int) RegistrationToken_ProjectLimit_Field {
	return RegistrationToken_ProjectLimit_Field{_set: true, _value: v}
}

func (f RegistrationToken_ProjectLimit_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_ProjectLimit_Field) _Column() string { return "project_limit" }

type RegistrationToken_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func RegistrationToken_CreatedAt(v time.Time) RegistrationToken_CreatedAt_Field {
	return RegistrationToken_CreatedAt_Field{_set: true, _value: v}
}

func (f RegistrationToken_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (RegistrationToken_CreatedAt_Field) _Column() string { return "created_at" }

type SerialNumber struct {
	Id           int
	SerialNumber []byte
	BucketId     []byte
	ExpiresAt    time.Time
}

func (SerialNumber) _Table() string { return "serial_numbers" }

type SerialNumber_Update_Fields struct {
}

type SerialNumber_Id_Field struct {
	_set   bool
	_null  bool
	_value int
}

func SerialNumber_Id(v int) SerialNumber_Id_Field {
	return SerialNumber_Id_Field{_set: true, _value: v}
}

func (f SerialNumber_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_Id_Field) _Column() string { return "id" }

type SerialNumber_SerialNumber_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func SerialNumber_SerialNumber(v []byte) SerialNumber_SerialNumber_Field {
	return SerialNumber_SerialNumber_Field{_set: true, _value: v}
}

func (f SerialNumber_SerialNumber_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_SerialNumber_Field) _Column() string { return "serial_number" }

type SerialNumber_BucketId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func SerialNumber_BucketId(v []byte) SerialNumber_BucketId_Field {
	return SerialNumber_BucketId_Field{_set: true, _value: v}
}

func (f SerialNumber_BucketId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_BucketId_Field) _Column() string { return "bucket_id" }

type SerialNumber_ExpiresAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func SerialNumber_ExpiresAt(v time.Time) SerialNumber_ExpiresAt_Field {
	v = toUTC(v)
	return SerialNumber_ExpiresAt_Field{_set: true, _value: v}
}

func (f SerialNumber_ExpiresAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (SerialNumber_ExpiresAt_Field) _Column() string { return "expires_at" }

type StoragenodeBandwidthRollup struct {
	StoragenodeId   []byte
	IntervalStart   time.Time
	IntervalSeconds uint
	Action          uint
	Allocated       uint64
	Settled         uint64
}

func (StoragenodeBandwidthRollup) _Table() string { return "storagenode_bandwidth_rollups" }

type StoragenodeBandwidthRollup_Update_Fields struct {
}

type StoragenodeBandwidthRollup_StoragenodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func StoragenodeBandwidthRollup_StoragenodeId(v []byte) StoragenodeBandwidthRollup_StoragenodeId_Field {
	return StoragenodeBandwidthRollup_StoragenodeId_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_StoragenodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_StoragenodeId_Field) _Column() string { return "storagenode_id" }

type StoragenodeBandwidthRollup_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func StoragenodeBandwidthRollup_IntervalStart(v time.Time) StoragenodeBandwidthRollup_IntervalStart_Field {
	v = toUTC(v)
	return StoragenodeBandwidthRollup_IntervalStart_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_IntervalStart_Field) _Column() string { return "interval_start" }

type StoragenodeBandwidthRollup_IntervalSeconds_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func StoragenodeBandwidthRollup_IntervalSeconds(v uint) StoragenodeBandwidthRollup_IntervalSeconds_Field {
	return StoragenodeBandwidthRollup_IntervalSeconds_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_IntervalSeconds_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_IntervalSeconds_Field) _Column() string { return "interval_seconds" }

type StoragenodeBandwidthRollup_Action_Field struct {
	_set   bool
	_null  bool
	_value uint
}

func StoragenodeBandwidthRollup_Action(v uint) StoragenodeBandwidthRollup_Action_Field {
	return StoragenodeBandwidthRollup_Action_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_Action_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_Action_Field) _Column() string { return "action" }

type StoragenodeBandwidthRollup_Allocated_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func StoragenodeBandwidthRollup_Allocated(v uint64) StoragenodeBandwidthRollup_Allocated_Field {
	return StoragenodeBandwidthRollup_Allocated_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_Allocated_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_Allocated_Field) _Column() string { return "allocated" }

type StoragenodeBandwidthRollup_Settled_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func StoragenodeBandwidthRollup_Settled(v uint64) StoragenodeBandwidthRollup_Settled_Field {
	return StoragenodeBandwidthRollup_Settled_Field{_set: true, _value: v}
}

func (f StoragenodeBandwidthRollup_Settled_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeBandwidthRollup_Settled_Field) _Column() string { return "settled" }

type StoragenodeStorageTally struct {
	StoragenodeId []byte
	IntervalStart time.Time
	Total         uint64
}

func (StoragenodeStorageTally) _Table() string { return "storagenode_storage_tallies" }

type StoragenodeStorageTally_Update_Fields struct {
}

type StoragenodeStorageTally_StoragenodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func StoragenodeStorageTally_StoragenodeId(v []byte) StoragenodeStorageTally_StoragenodeId_Field {
	return StoragenodeStorageTally_StoragenodeId_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_StoragenodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_StoragenodeId_Field) _Column() string { return "storagenode_id" }

type StoragenodeStorageTally_IntervalStart_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func StoragenodeStorageTally_IntervalStart(v time.Time) StoragenodeStorageTally_IntervalStart_Field {
	v = toUTC(v)
	return StoragenodeStorageTally_IntervalStart_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_IntervalStart_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_IntervalStart_Field) _Column() string { return "interval_start" }

type StoragenodeStorageTally_Total_Field struct {
	_set   bool
	_null  bool
	_value uint64
}

func StoragenodeStorageTally_Total(v uint64) StoragenodeStorageTally_Total_Field {
	return StoragenodeStorageTally_Total_Field{_set: true, _value: v}
}

func (f StoragenodeStorageTally_Total_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (StoragenodeStorageTally_Total_Field) _Column() string { return "total" }

type User struct {
	Id           []byte
	FullName     string
	ShortName    *string
	Email        string
	PasswordHash []byte
	Status       int
	CreatedAt    time.Time
}

func (User) _Table() string { return "users" }

type User_Create_Fields struct {
	ShortName User_ShortName_Field
}

type User_Update_Fields struct {
	FullName     User_FullName_Field
	ShortName    User_ShortName_Field
	Email        User_Email_Field
	PasswordHash User_PasswordHash_Field
	Status       User_Status_Field
}

type User_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func User_Id(v []byte) User_Id_Field {
	return User_Id_Field{_set: true, _value: v}
}

func (f User_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Id_Field) _Column() string { return "id" }

type User_FullName_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_FullName(v string) User_FullName_Field {
	return User_FullName_Field{_set: true, _value: v}
}

func (f User_FullName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_FullName_Field) _Column() string { return "full_name" }

type User_ShortName_Field struct {
	_set   bool
	_null  bool
	_value *string
}

func User_ShortName(v string) User_ShortName_Field {
	return User_ShortName_Field{_set: true, _value: &v}
}

func User_ShortName_Raw(v *string) User_ShortName_Field {
	if v == nil {
		return User_ShortName_Null()
	}
	return User_ShortName(*v)
}

func User_ShortName_Null() User_ShortName_Field {
	return User_ShortName_Field{_set: true, _null: true}
}

func (f User_ShortName_Field) isnull() bool { return !f._set || f._null || f._value == nil }

func (f User_ShortName_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_ShortName_Field) _Column() string { return "short_name" }

type User_Email_Field struct {
	_set   bool
	_null  bool
	_value string
}

func User_Email(v string) User_Email_Field {
	return User_Email_Field{_set: true, _value: v}
}

func (f User_Email_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Email_Field) _Column() string { return "email" }

type User_PasswordHash_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func User_PasswordHash(v []byte) User_PasswordHash_Field {
	return User_PasswordHash_Field{_set: true, _value: v}
}

func (f User_PasswordHash_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_PasswordHash_Field) _Column() string { return "password_hash" }

type User_Status_Field struct {
	_set   bool
	_null  bool
	_value int
}

func User_Status(v int) User_Status_Field {
	return User_Status_Field{_set: true, _value: v}
}

func (f User_Status_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_Status_Field) _Column() string { return "status" }

type User_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func User_CreatedAt(v time.Time) User_CreatedAt_Field {
	return User_CreatedAt_Field{_set: true, _value: v}
}

func (f User_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (User_CreatedAt_Field) _Column() string { return "created_at" }

type ApiKey struct {
	Id        []byte
	ProjectId []byte
	Key       []byte
	Name      string
	CreatedAt time.Time
}

func (ApiKey) _Table() string { return "api_keys" }

type ApiKey_Update_Fields struct {
	Name ApiKey_Name_Field
}

type ApiKey_Id_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_Id(v []byte) ApiKey_Id_Field {
	return ApiKey_Id_Field{_set: true, _value: v}
}

func (f ApiKey_Id_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Id_Field) _Column() string { return "id" }

type ApiKey_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_ProjectId(v []byte) ApiKey_ProjectId_Field {
	return ApiKey_ProjectId_Field{_set: true, _value: v}
}

func (f ApiKey_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_ProjectId_Field) _Column() string { return "project_id" }

type ApiKey_Key_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ApiKey_Key(v []byte) ApiKey_Key_Field {
	return ApiKey_Key_Field{_set: true, _value: v}
}

func (f ApiKey_Key_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Key_Field) _Column() string { return "key" }

type ApiKey_Name_Field struct {
	_set   bool
	_null  bool
	_value string
}

func ApiKey_Name(v string) ApiKey_Name_Field {
	return ApiKey_Name_Field{_set: true, _value: v}
}

func (f ApiKey_Name_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_Name_Field) _Column() string { return "name" }

type ApiKey_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ApiKey_CreatedAt(v time.Time) ApiKey_CreatedAt_Field {
	return ApiKey_CreatedAt_Field{_set: true, _value: v}
}

func (f ApiKey_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ApiKey_CreatedAt_Field) _Column() string { return "created_at" }

type ProjectMember struct {
	MemberId  []byte
	ProjectId []byte
	CreatedAt time.Time
}

func (ProjectMember) _Table() string { return "project_members" }

type ProjectMember_Update_Fields struct {
}

type ProjectMember_MemberId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectMember_MemberId(v []byte) ProjectMember_MemberId_Field {
	return ProjectMember_MemberId_Field{_set: true, _value: v}
}

func (f ProjectMember_MemberId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectMember_MemberId_Field) _Column() string { return "member_id" }

type ProjectMember_ProjectId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func ProjectMember_ProjectId(v []byte) ProjectMember_ProjectId_Field {
	return ProjectMember_ProjectId_Field{_set: true, _value: v}
}

func (f ProjectMember_ProjectId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectMember_ProjectId_Field) _Column() string { return "project_id" }

type ProjectMember_CreatedAt_Field struct {
	_set   bool
	_null  bool
	_value time.Time
}

func ProjectMember_CreatedAt(v time.Time) ProjectMember_CreatedAt_Field {
	return ProjectMember_CreatedAt_Field{_set: true, _value: v}
}

func (f ProjectMember_CreatedAt_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (ProjectMember_CreatedAt_Field) _Column() string { return "created_at" }

type UsedSerial struct {
	SerialNumberId int
	StorageNodeId  []byte
}

func (UsedSerial) _Table() string { return "used_serials" }

type UsedSerial_Update_Fields struct {
}

type UsedSerial_SerialNumberId_Field struct {
	_set   bool
	_null  bool
	_value int
}

func UsedSerial_SerialNumberId(v int) UsedSerial_SerialNumberId_Field {
	return UsedSerial_SerialNumberId_Field{_set: true, _value: v}
}

func (f UsedSerial_SerialNumberId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UsedSerial_SerialNumberId_Field) _Column() string { return "serial_number_id" }

type UsedSerial_StorageNodeId_Field struct {
	_set   bool
	_null  bool
	_value []byte
}

func UsedSerial_StorageNodeId(v []byte) UsedSerial_StorageNodeId_Field {
	return UsedSerial_StorageNodeId_Field{_set: true, _value: v}
}

func (f UsedSerial_StorageNodeId_Field) value() interface{} {
	if !f._set || f._null {
		return nil
	}
	return f._value
}

func (UsedSerial_StorageNodeId_Field) _Column() string { return "storage_node_id" }

func toUTC(t time.Time) time.Time {
	return t.UTC()
}

func toDate(t time.Time) time.Time {
	// keep up the minute portion so that translations between timezones will
	// continue to reflect properly.
	return t.Truncate(time.Minute)
}

//
// runtime support for building sql statements
//

type __sqlbundle_SQL interface {
	Render() string

	private()
}

type __sqlbundle_Dialect interface {
	Rebind(sql string) string
}

type __sqlbundle_RenderOp int

const (
	__sqlbundle_NoFlatten __sqlbundle_RenderOp = iota
	__sqlbundle_NoTerminate
)

func __sqlbundle_Render(dialect __sqlbundle_Dialect, sql __sqlbundle_SQL, ops ...__sqlbundle_RenderOp) string {
	out := sql.Render()

	flatten := true
	terminate := true
	for _, op := range ops {
		switch op {
		case __sqlbundle_NoFlatten:
			flatten = false
		case __sqlbundle_NoTerminate:
			terminate = false
		}
	}

	if flatten {
		out = __sqlbundle_flattenSQL(out)
	}
	if terminate {
		out += ";"
	}

	return dialect.Rebind(out)
}

func __sqlbundle_flattenSQL(x string) string {
	// trim whitespace from beginning and end
	s, e := 0, len(x)-1
	for s < len(x) && (x[s] == ' ' || x[s] == '\t' || x[s] == '\n') {
		s++
	}
	for s <= e && (x[e] == ' ' || x[e] == '\t' || x[e] == '\n') {
		e--
	}
	if s > e {
		return ""
	}
	x = x[s : e+1]

	// check for whitespace that needs fixing
	wasSpace := false
	for i := 0; i < len(x); i++ {
		r := x[i]
		justSpace := r == ' '
		if (wasSpace && justSpace) || r == '\t' || r == '\n' {
			// whitespace detected, start writing a new string
			var result strings.Builder
			result.Grow(len(x))
			if wasSpace {
				result.WriteString(x[:i-1])
			} else {
				result.WriteString(x[:i])
			}
			for p := i; p < len(x); p++ {
				for p < len(x) && (x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteByte(' ')

				start := p
				for p < len(x) && !(x[p] == ' ' || x[p] == '\t' || x[p] == '\n') {
					p++
				}
				result.WriteString(x[start:p])
			}

			return result.String()
		}
		wasSpace = justSpace
	}

	// no problematic whitespace found
	return x
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_postgres struct{}

func (p __sqlbundle_postgres) Rebind(sql string) string {
	out := make([]byte, 0, len(sql)+10)

	j := 1
	for i := 0; i < len(sql); i++ {
		ch := sql[i]
		if ch != '?' {
			out = append(out, ch)
			continue
		}

		out = append(out, '$')
		out = append(out, strconv.Itoa(j)...)
		j++
	}

	return string(out)
}

// this type is specially named to match up with the name returned by the
// dialect impl in the sql package.
type __sqlbundle_sqlite3 struct{}

func (s __sqlbundle_sqlite3) Rebind(sql string) string {
	return sql
}

type __sqlbundle_Literal string

func (__sqlbundle_Literal) private() {}

func (l __sqlbundle_Literal) Render() string { return string(l) }

type __sqlbundle_Literals struct {
	Join string
	SQLs []__sqlbundle_SQL
}

func (__sqlbundle_Literals) private() {}

func (l __sqlbundle_Literals) Render() string {
	var out bytes.Buffer

	first := true
	for _, sql := range l.SQLs {
		if sql == nil {
			continue
		}
		if !first {
			out.WriteString(l.Join)
		}
		first = false
		out.WriteString(sql.Render())
	}

	return out.String()
}

type __sqlbundle_Condition struct {
	// set at compile/embed time
	Name  string
	Left  string
	Equal bool
	Right string

	// set at runtime
	Null bool
}

func (*__sqlbundle_Condition) private() {}

func (c *__sqlbundle_Condition) Render() string {
	// TODO(jeff): maybe check if we can use placeholders instead of the
	// literal null: this would make the templates easier.

	switch {
	case c.Equal && c.Null:
		return c.Left + " is null"
	case c.Equal && !c.Null:
		return c.Left + " = " + c.Right
	case !c.Equal && c.Null:
		return c.Left + " is not null"
	case !c.Equal && !c.Null:
		return c.Left + " != " + c.Right
	default:
		panic("unhandled case")
	}
}

type __sqlbundle_Hole struct {
	// set at compiile/embed time
	Name string

	// set at runtime
	SQL __sqlbundle_SQL
}

func (*__sqlbundle_Hole) private() {}

func (h *__sqlbundle_Hole) Render() string { return h.SQL.Render() }

//
// end runtime support for building sql statements
//

type Id_Row struct {
	Id []byte
}

type Value_Row struct {
	Value time.Time
}

func (obj *postgresImpl) Create_Irreparabledb(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
	irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
	irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
	irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
	irreparabledb *Irreparabledb, err error) {
	__segmentpath_val := irreparabledb_segmentpath.value()
	__segmentdetail_val := irreparabledb_segmentdetail.value()
	__pieces_lost_count_val := irreparabledb_pieces_lost_count.value()
	__seg_damaged_unix_sec_val := irreparabledb_seg_damaged_unix_sec.value()
	__repair_attempt_count_val := irreparabledb_repair_attempt_count.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO irreparabledbs ( segmentpath, segmentdetail, pieces_lost_count, seg_damaged_unix_sec, repair_attempt_count ) VALUES ( ?, ?, ?, ?, ? ) RETURNING irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *postgresImpl) Create_AccountingTimestamps(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	accounting_timestamps_value AccountingTimestamps_Value_Field) (
	accounting_timestamps *AccountingTimestamps, err error) {
	__name_val := accounting_timestamps_name.value()
	__value_val := accounting_timestamps_value.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_timestamps ( name, value ) VALUES ( ?, ? ) RETURNING accounting_timestamps.name, accounting_timestamps.value")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __name_val, __value_val)

	accounting_timestamps = &AccountingTimestamps{}
	err = obj.driver.QueryRow(__stmt, __name_val, __value_val).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil

}

func (obj *postgresImpl) Create_AccountingRollup(ctx context.Context,
	accounting_rollup_node_id AccountingRollup_NodeId_Field,
	accounting_rollup_start_time AccountingRollup_StartTime_Field,
	accounting_rollup_put_total AccountingRollup_PutTotal_Field,
	accounting_rollup_get_total AccountingRollup_GetTotal_Field,
	accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
	accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
	accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
	accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
	accounting_rollup *AccountingRollup, err error) {
	__node_id_val := accounting_rollup_node_id.value()
	__start_time_val := accounting_rollup_start_time.value()
	__put_total_val := accounting_rollup_put_total.value()
	__get_total_val := accounting_rollup_get_total.value()
	__get_audit_total_val := accounting_rollup_get_audit_total.value()
	__get_repair_total_val := accounting_rollup_get_repair_total.value()
	__put_repair_total_val := accounting_rollup_put_repair_total.value()
	__at_rest_total_val := accounting_rollup_at_rest_total.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_rollups ( node_id, start_time, put_total, get_total, get_audit_total, get_repair_total, put_repair_total, at_rest_total ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *postgresImpl) Create_AccountingRaw(ctx context.Context,
	accounting_raw_node_id AccountingRaw_NodeId_Field,
	accounting_raw_interval_end_time AccountingRaw_IntervalEndTime_Field,
	accounting_raw_data_total AccountingRaw_DataTotal_Field,
	accounting_raw_data_type AccountingRaw_DataType_Field,
	accounting_raw_created_at AccountingRaw_CreatedAt_Field) (
	accounting_raw *AccountingRaw, err error) {
	__node_id_val := accounting_raw_node_id.value()
	__interval_end_time_val := accounting_raw_interval_end_time.value()
	__data_total_val := accounting_raw_data_total.value()
	__data_type_val := accounting_raw_data_type.value()
	__created_at_val := accounting_raw_created_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_raws ( node_id, interval_end_time, data_total, data_type, created_at ) VALUES ( ?, ?, ?, ?, ? ) RETURNING accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __interval_end_time_val, __data_total_val, __data_type_val, __created_at_val)

	accounting_raw = &AccountingRaw{}
	err = obj.driver.QueryRow(__stmt, __node_id_val, __interval_end_time_val, __data_total_val, __data_type_val, __created_at_val).Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_raw, nil

}

func (obj *postgresImpl) Create_Node(ctx context.Context,
	node_id Node_Id_Field,
	node_address Node_Address_Field,
	node_protocol Node_Protocol_Field,
	node_type Node_Type_Field,
	node_email Node_Email_Field,
	node_wallet Node_Wallet_Field,
	node_free_bandwidth Node_FreeBandwidth_Field,
	node_free_disk Node_FreeDisk_Field,
	node_latency_90 Node_Latency90_Field,
	node_audit_success_count Node_AuditSuccessCount_Field,
	node_total_audit_count Node_TotalAuditCount_Field,
	node_audit_success_ratio Node_AuditSuccessRatio_Field,
	node_uptime_success_count Node_UptimeSuccessCount_Field,
	node_total_uptime_count Node_TotalUptimeCount_Field,
	node_uptime_ratio Node_UptimeRatio_Field,
	node_last_contact_success Node_LastContactSuccess_Field,
	node_last_contact_failure Node_LastContactFailure_Field) (
	node *Node, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := node_id.value()
	__address_val := node_address.value()
	__protocol_val := node_protocol.value()
	__type_val := node_type.value()
	__email_val := node_email.value()
	__wallet_val := node_wallet.value()
	__free_bandwidth_val := node_free_bandwidth.value()
	__free_disk_val := node_free_disk.value()
	__latency_90_val := node_latency_90.value()
	__audit_success_count_val := node_audit_success_count.value()
	__total_audit_count_val := node_total_audit_count.value()
	__audit_success_ratio_val := node_audit_success_ratio.value()
	__uptime_success_count_val := node_uptime_success_count.value()
	__total_uptime_count_val := node_total_uptime_count.value()
	__uptime_ratio_val := node_uptime_ratio.value()
	__created_at_val := __now
	__updated_at_val := __now
	__last_contact_success_val := node_last_contact_success.value()
	__last_contact_failure_val := node_last_contact_failure.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO nodes ( id, address, protocol, type, email, wallet, free_bandwidth, free_disk, latency_90, audit_success_count, total_audit_count, audit_success_ratio, uptime_success_count, total_uptime_count, uptime_ratio, created_at, updated_at, last_contact_success, last_contact_failure ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __address_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __audit_success_ratio_val, __uptime_success_count_val, __total_uptime_count_val, __uptime_ratio_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __id_val, __address_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __audit_success_ratio_val, __uptime_success_count_val, __total_uptime_count_val, __uptime_ratio_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val).Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *postgresImpl) Create_Injuredsegment(ctx context.Context,
	injuredsegment_info Injuredsegment_Info_Field) (
	injuredsegment *Injuredsegment, err error) {
	__info_val := injuredsegment_info.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO injuredsegments ( info ) VALUES ( ? ) RETURNING injuredsegments.id, injuredsegments.info")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __info_val)

	injuredsegment = &Injuredsegment{}
	err = obj.driver.QueryRow(__stmt, __info_val).Scan(&injuredsegment.Id, &injuredsegment.Info)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return injuredsegment, nil

}

func (obj *postgresImpl) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_full_name User_FullName_Field,
	user_email User_Email_Field,
	user_password_hash User_PasswordHash_Field,
	optional User_Create_Fields) (
	user *User, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := user_id.value()
	__full_name_val := user_full_name.value()
	__short_name_val := optional.ShortName.value()
	__email_val := user_email.value()
	__password_hash_val := user_password_hash.value()
	__status_val := int(0)
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO users ( id, full_name, short_name, email, password_hash, status, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) RETURNING users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __full_name_val, __short_name_val, __email_val, __password_hash_val, __status_val, __created_at_val)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __id_val, __full_name_val, __short_name_val, __email_val, __password_hash_val, __status_val, __created_at_val).Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) Create_Project(ctx context.Context,
	project_id Project_Id_Field,
	project_name Project_Name_Field,
	project_description Project_Description_Field) (
	project *Project, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := project_id.value()
	__name_val := project_name.value()
	__description_val := project_description.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO projects ( id, name, description, created_at ) VALUES ( ?, ?, ?, ? ) RETURNING projects.id, projects.name, projects.description, projects.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __name_val, __description_val, __created_at_val)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __id_val, __name_val, __description_val, __created_at_val).Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *postgresImpl) Create_ProjectMember(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	project_member *ProjectMember, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__member_id_val := project_member_member_id.value()
	__project_id_val := project_member_project_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_members ( member_id, project_id, created_at ) VALUES ( ?, ?, ? ) RETURNING project_members.member_id, project_members.project_id, project_members.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __member_id_val, __project_id_val, __created_at_val)

	project_member = &ProjectMember{}
	err = obj.driver.QueryRow(__stmt, __member_id_val, __project_id_val, __created_at_val).Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_member, nil

}

func (obj *postgresImpl) Create_ApiKey(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	api_key_project_id ApiKey_ProjectId_Field,
	api_key_key ApiKey_Key_Field,
	api_key_name ApiKey_Name_Field) (
	api_key *ApiKey, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := api_key_id.value()
	__project_id_val := api_key_project_id.value()
	__key_val := api_key_key.value()
	__name_val := api_key_name.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO api_keys ( id, project_id, key, name, created_at ) VALUES ( ?, ?, ?, ?, ? ) RETURNING api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __key_val, __name_val, __created_at_val)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __id_val, __project_id_val, __key_val, __name_val, __created_at_val).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *postgresImpl) Create_BucketUsage(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
	bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
	bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
	bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
	bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
	bucket_usage_objects BucketUsage_Objects_Field,
	bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
	bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
	bucket_usage_get_egress BucketUsage_GetEgress_Field,
	bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
	bucket_usage *BucketUsage, err error) {
	__id_val := bucket_usage_id.value()
	__bucket_id_val := bucket_usage_bucket_id.value()
	__rollup_end_time_val := bucket_usage_rollup_end_time.value()
	__remote_stored_data_val := bucket_usage_remote_stored_data.value()
	__inline_stored_data_val := bucket_usage_inline_stored_data.value()
	__remote_segments_val := bucket_usage_remote_segments.value()
	__inline_segments_val := bucket_usage_inline_segments.value()
	__objects_val := bucket_usage_objects.value()
	__metadata_size_val := bucket_usage_metadata_size.value()
	__repair_egress_val := bucket_usage_repair_egress.value()
	__get_egress_val := bucket_usage_get_egress.value()
	__audit_egress_val := bucket_usage_audit_egress.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_usages ( id, bucket_id, rollup_end_time, remote_stored_data, inline_stored_data, remote_segments, inline_segments, objects, metadata_size, repair_egress, get_egress, audit_egress ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *postgresImpl) Create_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field,
	serial_number_bucket_id SerialNumber_BucketId_Field,
	serial_number_expires_at SerialNumber_ExpiresAt_Field) (
	serial_number *SerialNumber, err error) {
	__serial_number_val := serial_number_serial_number.value()
	__bucket_id_val := serial_number_bucket_id.value()
	__expires_at_val := serial_number_expires_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO serial_numbers ( serial_number, bucket_id, expires_at ) VALUES ( ?, ?, ? ) RETURNING serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val)

	serial_number = &SerialNumber{}
	err = obj.driver.QueryRow(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val).Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return serial_number, nil

}

func (obj *postgresImpl) Create_UsedSerial(ctx context.Context,
	used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
	used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
	used_serial *UsedSerial, err error) {
	__serial_number_id_val := used_serial_serial_number_id.value()
	__storage_node_id_val := used_serial_storage_node_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO used_serials ( serial_number_id, storage_node_id ) VALUES ( ?, ? ) RETURNING used_serials.serial_number_id, used_serials.storage_node_id")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_id_val, __storage_node_id_val)

	used_serial = &UsedSerial{}
	err = obj.driver.QueryRow(__stmt, __serial_number_id_val, __storage_node_id_val).Scan(&used_serial.SerialNumberId, &used_serial.StorageNodeId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return used_serial, nil

}

func (obj *postgresImpl) Create_BucketStorageTally(ctx context.Context,
	bucket_storage_tally_bucket_id BucketStorageTally_BucketId_Field,
	bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_inline BucketStorageTally_Inline_Field,
	bucket_storage_tally_remote BucketStorageTally_Remote_Field,
	bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
	bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
	bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
	bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	__bucket_id_val := bucket_storage_tally_bucket_id.value()
	__interval_start_val := bucket_storage_tally_interval_start.value()
	__inline_val := bucket_storage_tally_inline.value()
	__remote_val := bucket_storage_tally_remote.value()
	__remote_segments_count_val := bucket_storage_tally_remote_segments_count.value()
	__inline_segments_count_val := bucket_storage_tally_inline_segments_count.value()
	__object_count_val := bucket_storage_tally_object_count.value()
	__metadata_size_val := bucket_storage_tally_metadata_size.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_storage_tallies ( bucket_id, interval_start, inline, remote, remote_segments_count, inline_segments_count, object_count, metadata_size ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? ) RETURNING bucket_storage_tallies.bucket_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __bucket_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val)

	bucket_storage_tally = &BucketStorageTally{}
	err = obj.driver.QueryRow(__stmt, __bucket_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val).Scan(&bucket_storage_tally.BucketId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_storage_tally, nil

}

func (obj *postgresImpl) Create_CertRecord(ctx context.Context,
	certRecord_publickey CertRecord_Publickey_Field,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__publickey_val := certRecord_publickey.value()
	__id_val := certRecord_id.value()
	__update_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO certRecords ( publickey, id, update_at ) VALUES ( ?, ?, ? ) RETURNING certRecords.publickey, certRecords.id, certRecords.update_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __publickey_val, __id_val, __update_at_val)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __publickey_val, __id_val, __update_at_val).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *postgresImpl) Create_RegistrationToken(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	registration_token_project_limit RegistrationToken_ProjectLimit_Field,
	optional RegistrationToken_Create_Fields) (
	registration_token *RegistrationToken, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__secret_val := registration_token_secret.value()
	__owner_id_val := optional.OwnerId.value()
	__project_limit_val := registration_token_project_limit.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO registration_tokens ( secret, owner_id, project_limit, created_at ) VALUES ( ?, ?, ?, ? ) RETURNING registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *postgresImpl) Get_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	irreparabledb *Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *postgresImpl) Limited_Irreparabledb_OrderBy_Asc_Segmentpath(ctx context.Context,
	limit int, offset int64) (
	rows []*Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs ORDER BY irreparabledbs.segmentpath LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values)

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		irreparabledb := &Irreparabledb{}
		err = __rows.Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, irreparabledb)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field) (
	row *Value_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_timestamps.value FROM accounting_timestamps WHERE accounting_timestamps.name = ?")

	var __values []interface{}
	__values = append(__values, accounting_timestamps_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	row = &Value_Row{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&row.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return row, nil

}

func (obj *postgresImpl) Get_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	accounting_rollup *AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *postgresImpl) All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
	accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
	rows []*AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.start_time >= ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_start_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_rollup := &AccountingRollup{}
		err = __rows.Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_rollup)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_AccountingRaw_By_Id(ctx context.Context,
	accounting_raw_id AccountingRaw_Id_Field) (
	accounting_raw *AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws WHERE accounting_raws.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_raw_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_raw = &AccountingRaw{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_raw, nil

}

func (obj *postgresImpl) All_AccountingRaw(ctx context.Context) (
	rows []*AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_raw := &AccountingRaw{}
		err = __rows.Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_raw)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_AccountingRaw_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
	accounting_raw_interval_end_time_greater_or_equal AccountingRaw_IntervalEndTime_Field) (
	rows []*AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws WHERE accounting_raws.interval_end_time >= ?")

	var __values []interface{}
	__values = append(__values, accounting_raw_interval_end_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_raw := &AccountingRaw{}
		err = __rows.Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_raw)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	node *Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *postgresImpl) All_Node_Id(ctx context.Context) (
	rows []*Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id FROM nodes")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Id_Row{}
		err = __rows.Scan(&row.Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure FROM nodes WHERE nodes.id >= ? ORDER BY nodes.id LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, node_id_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		node := &Node{}
		err = __rows.Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, node)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) First_Injuredsegment(ctx context.Context) (
	injuredsegment *Injuredsegment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT injuredsegments.id, injuredsegments.info FROM injuredsegments LIMIT 1 OFFSET 0")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	injuredsegment = &Injuredsegment{}
	err = __rows.Scan(&injuredsegment.Id, &injuredsegment.Info)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return injuredsegment, nil

}

func (obj *postgresImpl) Limited_Injuredsegment(ctx context.Context,
	limit int, offset int64) (
	rows []*Injuredsegment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT injuredsegments.id, injuredsegments.info FROM injuredsegments LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values)

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		injuredsegment := &Injuredsegment{}
		err = __rows.Scan(&injuredsegment.Id, &injuredsegment.Info)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, injuredsegment)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at FROM users WHERE users.email = ? AND users.status != 0 LIMIT 2")

	var __values []interface{}
	__values = append(__values, user_email.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	user = &User{}
	err = __rows.Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("User_By_Email_And_Status_Not_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return user, nil

}

func (obj *postgresImpl) Get_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *postgresImpl) All_Project(ctx context.Context) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	project *Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *postgresImpl) All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects  JOIN project_members ON projects.id = project_members.project_id WHERE project_members.member_id = ? ORDER BY projects.name")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) All_ProjectMember_By_MemberId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.member_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_ProjectMember_By_ProjectId(ctx context.Context,
	project_member_project_id ProjectMember_ProjectId_Field,
	limit int, offset int64) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.project_id = ? LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, project_member_project_id.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *postgresImpl) Get_ApiKey_By_Key(ctx context.Context,
	api_key_key ApiKey_Key_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.key = ?")

	var __values []interface{}
	__values = append(__values, api_key_key.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *postgresImpl) All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
	api_key_project_id ApiKey_ProjectId_Field) (
	rows []*ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.project_id = ? ORDER BY api_keys.name")

	var __values []interface{}
	__values = append(__values, api_key_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		api_key := &ApiKey{}
		err = __rows.Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, api_key)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Get_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	bucket_usage *BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *postgresImpl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time DESC LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *postgresImpl) Find_SerialNumber_By_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field) (
	serial_number *SerialNumber, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at FROM serial_numbers WHERE serial_numbers.serial_number = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, serial_number_serial_number.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	serial_number = &SerialNumber{}
	err = __rows.Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("SerialNumber_By_SerialNumber")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return serial_number, nil

}

func (obj *postgresImpl) Get_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *postgresImpl) Get_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field) (
	registration_token *RegistrationToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE registration_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, registration_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *postgresImpl) Get_RegistrationToken_By_OwnerId(ctx context.Context,
	registration_token_owner_id RegistrationToken_OwnerId_Field) (
	registration_token *RegistrationToken, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "registration_tokens.owner_id", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !registration_token_owner_id.isnull() {
		__cond_0.Null = false
		__values = append(__values, registration_token_owner_id.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *postgresImpl) Update_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	update Irreparabledb_Update_Fields) (
	irreparabledb *Irreparabledb, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE irreparabledbs SET "), __sets, __sqlbundle_Literal(" WHERE irreparabledbs.segmentpath = ? RETURNING irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Segmentdetail._set {
		__values = append(__values, update.Segmentdetail.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("segmentdetail = ?"))
	}

	if update.PiecesLostCount._set {
		__values = append(__values, update.PiecesLostCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("pieces_lost_count = ?"))
	}

	if update.SegDamagedUnixSec._set {
		__values = append(__values, update.SegDamagedUnixSec.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("seg_damaged_unix_sec = ?"))
	}

	if update.RepairAttemptCount._set {
		__values = append(__values, update.RepairAttemptCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("repair_attempt_count = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, irreparabledb_segmentpath.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil
}

func (obj *postgresImpl) Update_AccountingTimestamps_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	update AccountingTimestamps_Update_Fields) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE accounting_timestamps SET "), __sets, __sqlbundle_Literal(" WHERE accounting_timestamps.name = ? RETURNING accounting_timestamps.name, accounting_timestamps.value")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Value._set {
		__values = append(__values, update.Value.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("value = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, accounting_timestamps_name.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_timestamps = &AccountingTimestamps{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil
}

func (obj *postgresImpl) Update_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE nodes SET "), __sets, __sqlbundle_Literal(" WHERE nodes.id = ? RETURNING nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Address._set {
		__values = append(__values, update.Address.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("address = ?"))
	}

	if update.Protocol._set {
		__values = append(__values, update.Protocol.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("protocol = ?"))
	}

	if update.Type._set {
		__values = append(__values, update.Type.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("type = ?"))
	}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.Wallet._set {
		__values = append(__values, update.Wallet.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("wallet = ?"))
	}

	if update.FreeBandwidth._set {
		__values = append(__values, update.FreeBandwidth.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_bandwidth = ?"))
	}

	if update.FreeDisk._set {
		__values = append(__values, update.FreeDisk.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_disk = ?"))
	}

	if update.Latency90._set {
		__values = append(__values, update.Latency90.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("latency_90 = ?"))
	}

	if update.AuditSuccessCount._set {
		__values = append(__values, update.AuditSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_success_count = ?"))
	}

	if update.TotalAuditCount._set {
		__values = append(__values, update.TotalAuditCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_audit_count = ?"))
	}

	if update.AuditSuccessRatio._set {
		__values = append(__values, update.AuditSuccessRatio.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_success_ratio = ?"))
	}

	if update.UptimeSuccessCount._set {
		__values = append(__values, update.UptimeSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_success_count = ?"))
	}

	if update.TotalUptimeCount._set {
		__values = append(__values, update.TotalUptimeCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_uptime_count = ?"))
	}

	if update.UptimeRatio._set {
		__values = append(__values, update.UptimeRatio.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_ratio = ?"))
	}

	if update.LastContactSuccess._set {
		__values = append(__values, update.LastContactSuccess.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_success = ?"))
	}

	if update.LastContactFailure._set {
		__values = append(__values, update.LastContactFailure.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_failure = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, node_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil
}

func (obj *postgresImpl) Update_User_By_Id(ctx context.Context,
	user_id User_Id_Field,
	update User_Update_Fields) (
	user *User, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE users SET "), __sets, __sqlbundle_Literal(" WHERE users.id = ? RETURNING users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.FullName._set {
		__values = append(__values, update.FullName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("full_name = ?"))
	}

	if update.ShortName._set {
		__values = append(__values, update.ShortName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("short_name = ?"))
	}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.PasswordHash._set {
		__values = append(__values, update.PasswordHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("password_hash = ?"))
	}

	if update.Status._set {
		__values = append(__values, update.Status.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("status = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, user_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil
}

func (obj *postgresImpl) Update_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field,
	update Project_Update_Fields) (
	project *Project, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE projects SET "), __sets, __sqlbundle_Literal(" WHERE projects.id = ? RETURNING projects.id, projects.name, projects.description, projects.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, project_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil
}

func (obj *postgresImpl) Update_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	update ApiKey_Update_Fields) (
	api_key *ApiKey, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE api_keys SET "), __sets, __sqlbundle_Literal(" WHERE api_keys.id = ? RETURNING api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Name._set {
		__values = append(__values, update.Name.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("name = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, api_key_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil
}

func (obj *postgresImpl) Update_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field,
	update CertRecord_Update_Fields) (
	certRecord *CertRecord, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE certRecords SET "), __sets, __sqlbundle_Literal(" WHERE certRecords.id = ? RETURNING certRecords.publickey, certRecords.id, certRecords.update_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("update_at = ?"))

	__args = append(__args, certRecord_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil
}

func (obj *postgresImpl) Update_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	update RegistrationToken_Update_Fields) (
	registration_token *RegistrationToken, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE registration_tokens SET "), __sets, __sqlbundle_Literal(" WHERE registration_tokens.secret = ? RETURNING registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.OwnerId._set {
		__values = append(__values, update.OwnerId.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("owner_id = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, registration_token_secret.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil
}

func (obj *postgresImpl) Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_AccountingRaw_By_Id(ctx context.Context,
	accounting_raw_id AccountingRaw_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM accounting_raws WHERE accounting_raws.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_raw_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_Injuredsegment_By_Id(ctx context.Context,
	injuredsegment_id Injuredsegment_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM injuredsegments WHERE injuredsegments.id = ?")

	var __values []interface{}
	__values = append(__values, injuredsegment_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM project_members WHERE project_members.member_id = ? AND project_members.project_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value(), project_member_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *postgresImpl) Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
	serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM serial_numbers WHERE serial_numbers.expires_at <= ?")

	var __values []interface{}
	__values = append(__values, serial_number_expires_at_less_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *postgresImpl) Delete_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (impl postgresImpl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(*pq.Error); ok {
		if e.Code.Class() == "23" {
			return e.Constraint, true
		}
	}
	return "", false
}

func (obj *postgresImpl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.Exec("DELETE FROM used_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM project_members;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM api_keys;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM serial_numbers;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM registration_tokens;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM projects;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM nodes;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM irreparabledbs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM injuredsegments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM certRecords;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bwagreements;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_usages;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_raws;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

func (obj *sqlite3Impl) Create_Irreparabledb(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
	irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
	irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
	irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
	irreparabledb *Irreparabledb, err error) {
	__segmentpath_val := irreparabledb_segmentpath.value()
	__segmentdetail_val := irreparabledb_segmentdetail.value()
	__pieces_lost_count_val := irreparabledb_pieces_lost_count.value()
	__seg_damaged_unix_sec_val := irreparabledb_seg_damaged_unix_sec.value()
	__repair_attempt_count_val := irreparabledb_repair_attempt_count.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO irreparabledbs ( segmentpath, segmentdetail, pieces_lost_count, seg_damaged_unix_sec, repair_attempt_count ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val)

	__res, err := obj.driver.Exec(__stmt, __segmentpath_val, __segmentdetail_val, __pieces_lost_count_val, __seg_damaged_unix_sec_val, __repair_attempt_count_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastIrreparabledb(ctx, __pk)

}

func (obj *sqlite3Impl) Create_AccountingTimestamps(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	accounting_timestamps_value AccountingTimestamps_Value_Field) (
	accounting_timestamps *AccountingTimestamps, err error) {
	__name_val := accounting_timestamps_name.value()
	__value_val := accounting_timestamps_value.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_timestamps ( name, value ) VALUES ( ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __name_val, __value_val)

	__res, err := obj.driver.Exec(__stmt, __name_val, __value_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastAccountingTimestamps(ctx, __pk)

}

func (obj *sqlite3Impl) Create_AccountingRollup(ctx context.Context,
	accounting_rollup_node_id AccountingRollup_NodeId_Field,
	accounting_rollup_start_time AccountingRollup_StartTime_Field,
	accounting_rollup_put_total AccountingRollup_PutTotal_Field,
	accounting_rollup_get_total AccountingRollup_GetTotal_Field,
	accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
	accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
	accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
	accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
	accounting_rollup *AccountingRollup, err error) {
	__node_id_val := accounting_rollup_node_id.value()
	__start_time_val := accounting_rollup_start_time.value()
	__put_total_val := accounting_rollup_put_total.value()
	__get_total_val := accounting_rollup_get_total.value()
	__get_audit_total_val := accounting_rollup_get_audit_total.value()
	__get_repair_total_val := accounting_rollup_get_repair_total.value()
	__put_repair_total_val := accounting_rollup_put_repair_total.value()
	__at_rest_total_val := accounting_rollup_at_rest_total.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_rollups ( node_id, start_time, put_total, get_total, get_audit_total, get_repair_total, put_repair_total, at_rest_total ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val)

	__res, err := obj.driver.Exec(__stmt, __node_id_val, __start_time_val, __put_total_val, __get_total_val, __get_audit_total_val, __get_repair_total_val, __put_repair_total_val, __at_rest_total_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastAccountingRollup(ctx, __pk)

}

func (obj *sqlite3Impl) Create_AccountingRaw(ctx context.Context,
	accounting_raw_node_id AccountingRaw_NodeId_Field,
	accounting_raw_interval_end_time AccountingRaw_IntervalEndTime_Field,
	accounting_raw_data_total AccountingRaw_DataTotal_Field,
	accounting_raw_data_type AccountingRaw_DataType_Field,
	accounting_raw_created_at AccountingRaw_CreatedAt_Field) (
	accounting_raw *AccountingRaw, err error) {
	__node_id_val := accounting_raw_node_id.value()
	__interval_end_time_val := accounting_raw_interval_end_time.value()
	__data_total_val := accounting_raw_data_total.value()
	__data_type_val := accounting_raw_data_type.value()
	__created_at_val := accounting_raw_created_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO accounting_raws ( node_id, interval_end_time, data_total, data_type, created_at ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __node_id_val, __interval_end_time_val, __data_total_val, __data_type_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __node_id_val, __interval_end_time_val, __data_total_val, __data_type_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastAccountingRaw(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Node(ctx context.Context,
	node_id Node_Id_Field,
	node_address Node_Address_Field,
	node_protocol Node_Protocol_Field,
	node_type Node_Type_Field,
	node_email Node_Email_Field,
	node_wallet Node_Wallet_Field,
	node_free_bandwidth Node_FreeBandwidth_Field,
	node_free_disk Node_FreeDisk_Field,
	node_latency_90 Node_Latency90_Field,
	node_audit_success_count Node_AuditSuccessCount_Field,
	node_total_audit_count Node_TotalAuditCount_Field,
	node_audit_success_ratio Node_AuditSuccessRatio_Field,
	node_uptime_success_count Node_UptimeSuccessCount_Field,
	node_total_uptime_count Node_TotalUptimeCount_Field,
	node_uptime_ratio Node_UptimeRatio_Field,
	node_last_contact_success Node_LastContactSuccess_Field,
	node_last_contact_failure Node_LastContactFailure_Field) (
	node *Node, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := node_id.value()
	__address_val := node_address.value()
	__protocol_val := node_protocol.value()
	__type_val := node_type.value()
	__email_val := node_email.value()
	__wallet_val := node_wallet.value()
	__free_bandwidth_val := node_free_bandwidth.value()
	__free_disk_val := node_free_disk.value()
	__latency_90_val := node_latency_90.value()
	__audit_success_count_val := node_audit_success_count.value()
	__total_audit_count_val := node_total_audit_count.value()
	__audit_success_ratio_val := node_audit_success_ratio.value()
	__uptime_success_count_val := node_uptime_success_count.value()
	__total_uptime_count_val := node_total_uptime_count.value()
	__uptime_ratio_val := node_uptime_ratio.value()
	__created_at_val := __now
	__updated_at_val := __now
	__last_contact_success_val := node_last_contact_success.value()
	__last_contact_failure_val := node_last_contact_failure.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO nodes ( id, address, protocol, type, email, wallet, free_bandwidth, free_disk, latency_90, audit_success_count, total_audit_count, audit_success_ratio, uptime_success_count, total_uptime_count, uptime_ratio, created_at, updated_at, last_contact_success, last_contact_failure ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __address_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __audit_success_ratio_val, __uptime_success_count_val, __total_uptime_count_val, __uptime_ratio_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __address_val, __protocol_val, __type_val, __email_val, __wallet_val, __free_bandwidth_val, __free_disk_val, __latency_90_val, __audit_success_count_val, __total_audit_count_val, __audit_success_ratio_val, __uptime_success_count_val, __total_uptime_count_val, __uptime_ratio_val, __created_at_val, __updated_at_val, __last_contact_success_val, __last_contact_failure_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastNode(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Injuredsegment(ctx context.Context,
	injuredsegment_info Injuredsegment_Info_Field) (
	injuredsegment *Injuredsegment, err error) {
	__info_val := injuredsegment_info.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO injuredsegments ( info ) VALUES ( ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __info_val)

	__res, err := obj.driver.Exec(__stmt, __info_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastInjuredsegment(ctx, __pk)

}

func (obj *sqlite3Impl) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_full_name User_FullName_Field,
	user_email User_Email_Field,
	user_password_hash User_PasswordHash_Field,
	optional User_Create_Fields) (
	user *User, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := user_id.value()
	__full_name_val := user_full_name.value()
	__short_name_val := optional.ShortName.value()
	__email_val := user_email.value()
	__password_hash_val := user_password_hash.value()
	__status_val := int(0)
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO users ( id, full_name, short_name, email, password_hash, status, created_at ) VALUES ( ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __full_name_val, __short_name_val, __email_val, __password_hash_val, __status_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __full_name_val, __short_name_val, __email_val, __password_hash_val, __status_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUser(ctx, __pk)

}

func (obj *sqlite3Impl) Create_Project(ctx context.Context,
	project_id Project_Id_Field,
	project_name Project_Name_Field,
	project_description Project_Description_Field) (
	project *Project, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := project_id.value()
	__name_val := project_name.value()
	__description_val := project_description.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO projects ( id, name, description, created_at ) VALUES ( ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __name_val, __description_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __name_val, __description_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastProject(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ProjectMember(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	project_member *ProjectMember, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__member_id_val := project_member_member_id.value()
	__project_id_val := project_member_project_id.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO project_members ( member_id, project_id, created_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __member_id_val, __project_id_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __member_id_val, __project_id_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastProjectMember(ctx, __pk)

}

func (obj *sqlite3Impl) Create_ApiKey(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	api_key_project_id ApiKey_ProjectId_Field,
	api_key_key ApiKey_Key_Field,
	api_key_name ApiKey_Name_Field) (
	api_key *ApiKey, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__id_val := api_key_id.value()
	__project_id_val := api_key_project_id.value()
	__key_val := api_key_key.value()
	__name_val := api_key_name.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO api_keys ( id, project_id, key, name, created_at ) VALUES ( ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __project_id_val, __key_val, __name_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __project_id_val, __key_val, __name_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastApiKey(ctx, __pk)

}

func (obj *sqlite3Impl) Create_BucketUsage(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
	bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
	bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
	bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
	bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
	bucket_usage_objects BucketUsage_Objects_Field,
	bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
	bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
	bucket_usage_get_egress BucketUsage_GetEgress_Field,
	bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
	bucket_usage *BucketUsage, err error) {
	__id_val := bucket_usage_id.value()
	__bucket_id_val := bucket_usage_bucket_id.value()
	__rollup_end_time_val := bucket_usage_rollup_end_time.value()
	__remote_stored_data_val := bucket_usage_remote_stored_data.value()
	__inline_stored_data_val := bucket_usage_inline_stored_data.value()
	__remote_segments_val := bucket_usage_remote_segments.value()
	__inline_segments_val := bucket_usage_inline_segments.value()
	__objects_val := bucket_usage_objects.value()
	__metadata_size_val := bucket_usage_metadata_size.value()
	__repair_egress_val := bucket_usage_repair_egress.value()
	__get_egress_val := bucket_usage_get_egress.value()
	__audit_egress_val := bucket_usage_audit_egress.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_usages ( id, bucket_id, rollup_end_time, remote_stored_data, inline_stored_data, remote_segments, inline_segments, objects, metadata_size, repair_egress, get_egress, audit_egress ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val)

	__res, err := obj.driver.Exec(__stmt, __id_val, __bucket_id_val, __rollup_end_time_val, __remote_stored_data_val, __inline_stored_data_val, __remote_segments_val, __inline_segments_val, __objects_val, __metadata_size_val, __repair_egress_val, __get_egress_val, __audit_egress_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastBucketUsage(ctx, __pk)

}

func (obj *sqlite3Impl) Create_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field,
	serial_number_bucket_id SerialNumber_BucketId_Field,
	serial_number_expires_at SerialNumber_ExpiresAt_Field) (
	serial_number *SerialNumber, err error) {
	__serial_number_val := serial_number_serial_number.value()
	__bucket_id_val := serial_number_bucket_id.value()
	__expires_at_val := serial_number_expires_at.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO serial_numbers ( serial_number, bucket_id, expires_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val)

	__res, err := obj.driver.Exec(__stmt, __serial_number_val, __bucket_id_val, __expires_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastSerialNumber(ctx, __pk)

}

func (obj *sqlite3Impl) Create_UsedSerial(ctx context.Context,
	used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
	used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
	used_serial *UsedSerial, err error) {
	__serial_number_id_val := used_serial_serial_number_id.value()
	__storage_node_id_val := used_serial_storage_node_id.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO used_serials ( serial_number_id, storage_node_id ) VALUES ( ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __serial_number_id_val, __storage_node_id_val)

	__res, err := obj.driver.Exec(__stmt, __serial_number_id_val, __storage_node_id_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastUsedSerial(ctx, __pk)

}

func (obj *sqlite3Impl) Create_BucketStorageTally(ctx context.Context,
	bucket_storage_tally_bucket_id BucketStorageTally_BucketId_Field,
	bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_inline BucketStorageTally_Inline_Field,
	bucket_storage_tally_remote BucketStorageTally_Remote_Field,
	bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
	bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
	bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
	bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	__bucket_id_val := bucket_storage_tally_bucket_id.value()
	__interval_start_val := bucket_storage_tally_interval_start.value()
	__inline_val := bucket_storage_tally_inline.value()
	__remote_val := bucket_storage_tally_remote.value()
	__remote_segments_count_val := bucket_storage_tally_remote_segments_count.value()
	__inline_segments_count_val := bucket_storage_tally_inline_segments_count.value()
	__object_count_val := bucket_storage_tally_object_count.value()
	__metadata_size_val := bucket_storage_tally_metadata_size.value()

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO bucket_storage_tallies ( bucket_id, interval_start, inline, remote, remote_segments_count, inline_segments_count, object_count, metadata_size ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __bucket_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val)

	__res, err := obj.driver.Exec(__stmt, __bucket_id_val, __interval_start_val, __inline_val, __remote_val, __remote_segments_count_val, __inline_segments_count_val, __object_count_val, __metadata_size_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastBucketStorageTally(ctx, __pk)

}

func (obj *sqlite3Impl) Create_CertRecord(ctx context.Context,
	certRecord_publickey CertRecord_Publickey_Field,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__publickey_val := certRecord_publickey.value()
	__id_val := certRecord_id.value()
	__update_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO certRecords ( publickey, id, update_at ) VALUES ( ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __publickey_val, __id_val, __update_at_val)

	__res, err := obj.driver.Exec(__stmt, __publickey_val, __id_val, __update_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastCertRecord(ctx, __pk)

}

func (obj *sqlite3Impl) Create_RegistrationToken(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	registration_token_project_limit RegistrationToken_ProjectLimit_Field,
	optional RegistrationToken_Create_Fields) (
	registration_token *RegistrationToken, err error) {

	__now := obj.db.Hooks.Now().UTC()
	__secret_val := registration_token_secret.value()
	__owner_id_val := optional.OwnerId.value()
	__project_limit_val := registration_token_project_limit.value()
	__created_at_val := __now

	var __embed_stmt = __sqlbundle_Literal("INSERT INTO registration_tokens ( secret, owner_id, project_limit, created_at ) VALUES ( ?, ?, ?, ? )")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val)

	__res, err := obj.driver.Exec(__stmt, __secret_val, __owner_id_val, __project_limit_val, __created_at_val)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	__pk, err := __res.LastInsertId()
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return obj.getLastRegistrationToken(ctx, __pk)

}

func (obj *sqlite3Impl) Get_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	irreparabledb *Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *sqlite3Impl) Limited_Irreparabledb_OrderBy_Asc_Segmentpath(ctx context.Context,
	limit int, offset int64) (
	rows []*Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs ORDER BY irreparabledbs.segmentpath LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values)

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		irreparabledb := &Irreparabledb{}
		err = __rows.Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, irreparabledb)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field) (
	row *Value_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_timestamps.value FROM accounting_timestamps WHERE accounting_timestamps.name = ?")

	var __values []interface{}
	__values = append(__values, accounting_timestamps_name.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	row = &Value_Row{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&row.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return row, nil

}

func (obj *sqlite3Impl) Get_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	accounting_rollup *AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *sqlite3Impl) All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
	accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
	rows []*AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE accounting_rollups.start_time >= ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_start_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_rollup := &AccountingRollup{}
		err = __rows.Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_rollup)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_AccountingRaw_By_Id(ctx context.Context,
	accounting_raw_id AccountingRaw_Id_Field) (
	accounting_raw *AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws WHERE accounting_raws.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_raw_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_raw = &AccountingRaw{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_raw, nil

}

func (obj *sqlite3Impl) All_AccountingRaw(ctx context.Context) (
	rows []*AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_raw := &AccountingRaw{}
		err = __rows.Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_raw)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_AccountingRaw_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
	accounting_raw_interval_end_time_greater_or_equal AccountingRaw_IntervalEndTime_Field) (
	rows []*AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws WHERE accounting_raws.interval_end_time >= ?")

	var __values []interface{}
	__values = append(__values, accounting_raw_interval_end_time_greater_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		accounting_raw := &AccountingRaw{}
		err = __rows.Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, accounting_raw)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	node *Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *sqlite3Impl) All_Node_Id(ctx context.Context) (
	rows []*Id_Row, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id FROM nodes")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		row := &Id_Row{}
		err = __rows.Scan(&row.Id)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, row)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure FROM nodes WHERE nodes.id >= ? ORDER BY nodes.id LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, node_id_greater_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		node := &Node{}
		err = __rows.Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, node)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) First_Injuredsegment(ctx context.Context) (
	injuredsegment *Injuredsegment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT injuredsegments.id, injuredsegments.info FROM injuredsegments LIMIT 1 OFFSET 0")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	injuredsegment = &Injuredsegment{}
	err = __rows.Scan(&injuredsegment.Id, &injuredsegment.Info)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	return injuredsegment, nil

}

func (obj *sqlite3Impl) Limited_Injuredsegment(ctx context.Context,
	limit int, offset int64) (
	rows []*Injuredsegment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT injuredsegments.id, injuredsegments.info FROM injuredsegments LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values)

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		injuredsegment := &Injuredsegment{}
		err = __rows.Scan(&injuredsegment.Id, &injuredsegment.Info)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, injuredsegment)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at FROM users WHERE users.email = ? AND users.status != 0 LIMIT 2")

	var __values []interface{}
	__values = append(__values, user_email.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, makeErr(sql.ErrNoRows)
	}

	user = &User{}
	err = __rows.Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("User_By_Email_And_Status_Not_Number")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return user, nil

}

func (obj *sqlite3Impl) Get_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) All_Project(ctx context.Context) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects")

	var __values []interface{}
	__values = append(__values)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	project *Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *sqlite3Impl) All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects  JOIN project_members ON projects.id = project_members.project_id WHERE project_members.member_id = ? ORDER BY projects.name")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project := &Project{}
		err = __rows.Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) All_ProjectMember_By_MemberId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.member_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_ProjectMember_By_ProjectId(ctx context.Context,
	project_member_project_id ProjectMember_ProjectId_Field,
	limit int, offset int64) (
	rows []*ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE project_members.project_id = ? LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, project_member_project_id.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		project_member := &ProjectMember{}
		err = __rows.Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, project_member)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *sqlite3Impl) Get_ApiKey_By_Key(ctx context.Context,
	api_key_key ApiKey_Key_Field) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.key = ?")

	var __values []interface{}
	__values = append(__values, api_key_key.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *sqlite3Impl) All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
	api_key_project_id ApiKey_ProjectId_Field) (
	rows []*ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.project_id = ? ORDER BY api_keys.name")

	var __values []interface{}
	__values = append(__values, api_key_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		api_key := &ApiKey{}
		err = __rows.Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, api_key)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Get_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	bucket_usage *BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *sqlite3Impl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE bucket_usages.bucket_id = ? AND bucket_usages.rollup_end_time > ? AND bucket_usages.rollup_end_time <= ? ORDER BY bucket_usages.rollup_end_time DESC LIMIT ? OFFSET ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_bucket_id.value(), bucket_usage_rollup_end_time_greater.value(), bucket_usage_rollup_end_time_less_or_equal.value())

	__values = append(__values, limit, offset)

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	for __rows.Next() {
		bucket_usage := &BucketUsage{}
		err = __rows.Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
		if err != nil {
			return nil, obj.makeErr(err)
		}
		rows = append(rows, bucket_usage)
	}
	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}
	return rows, nil

}

func (obj *sqlite3Impl) Find_SerialNumber_By_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field) (
	serial_number *SerialNumber, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at FROM serial_numbers WHERE serial_numbers.serial_number = ? LIMIT 2")

	var __values []interface{}
	__values = append(__values, serial_number_serial_number.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__rows, err := obj.driver.Query(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	defer __rows.Close()

	if !__rows.Next() {
		if err := __rows.Err(); err != nil {
			return nil, obj.makeErr(err)
		}
		return nil, nil
	}

	serial_number = &SerialNumber{}
	err = __rows.Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	if __rows.Next() {
		return nil, tooManyRows("SerialNumber_By_SerialNumber")
	}

	if err := __rows.Err(); err != nil {
		return nil, obj.makeErr(err)
	}

	return serial_number, nil

}

func (obj *sqlite3Impl) Get_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *sqlite3Impl) Get_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field) (
	registration_token *RegistrationToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE registration_tokens.secret = ?")

	var __values []interface{}
	__values = append(__values, registration_token_secret.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *sqlite3Impl) Get_RegistrationToken_By_OwnerId(ctx context.Context,
	registration_token_owner_id RegistrationToken_OwnerId_Field) (
	registration_token *RegistrationToken, err error) {

	var __cond_0 = &__sqlbundle_Condition{Left: "registration_tokens.owner_id", Equal: true, Right: "?", Null: true}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE "), __cond_0}}

	var __values []interface{}
	__values = append(__values)

	if !registration_token_owner_id.isnull() {
		__cond_0.Null = false
		__values = append(__values, registration_token_owner_id.value())
	}

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, __values...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (obj *sqlite3Impl) Update_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	update Irreparabledb_Update_Fields) (
	irreparabledb *Irreparabledb, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE irreparabledbs SET "), __sets, __sqlbundle_Literal(" WHERE irreparabledbs.segmentpath = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Segmentdetail._set {
		__values = append(__values, update.Segmentdetail.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("segmentdetail = ?"))
	}

	if update.PiecesLostCount._set {
		__values = append(__values, update.PiecesLostCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("pieces_lost_count = ?"))
	}

	if update.SegDamagedUnixSec._set {
		__values = append(__values, update.SegDamagedUnixSec.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("seg_damaged_unix_sec = ?"))
	}

	if update.RepairAttemptCount._set {
		__values = append(__values, update.RepairAttemptCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("repair_attempt_count = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, irreparabledb_segmentpath.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	irreparabledb = &Irreparabledb{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil
}

func (obj *sqlite3Impl) Update_AccountingTimestamps_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	update AccountingTimestamps_Update_Fields) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE accounting_timestamps SET "), __sets, __sqlbundle_Literal(" WHERE accounting_timestamps.name = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Value._set {
		__values = append(__values, update.Value.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("value = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, accounting_timestamps_name.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	accounting_timestamps = &AccountingTimestamps{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT accounting_timestamps.name, accounting_timestamps.value FROM accounting_timestamps WHERE accounting_timestamps.name = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil
}

func (obj *sqlite3Impl) Update_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE nodes SET "), __sets, __sqlbundle_Literal(" WHERE nodes.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Address._set {
		__values = append(__values, update.Address.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("address = ?"))
	}

	if update.Protocol._set {
		__values = append(__values, update.Protocol.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("protocol = ?"))
	}

	if update.Type._set {
		__values = append(__values, update.Type.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("type = ?"))
	}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.Wallet._set {
		__values = append(__values, update.Wallet.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("wallet = ?"))
	}

	if update.FreeBandwidth._set {
		__values = append(__values, update.FreeBandwidth.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_bandwidth = ?"))
	}

	if update.FreeDisk._set {
		__values = append(__values, update.FreeDisk.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("free_disk = ?"))
	}

	if update.Latency90._set {
		__values = append(__values, update.Latency90.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("latency_90 = ?"))
	}

	if update.AuditSuccessCount._set {
		__values = append(__values, update.AuditSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_success_count = ?"))
	}

	if update.TotalAuditCount._set {
		__values = append(__values, update.TotalAuditCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_audit_count = ?"))
	}

	if update.AuditSuccessRatio._set {
		__values = append(__values, update.AuditSuccessRatio.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("audit_success_ratio = ?"))
	}

	if update.UptimeSuccessCount._set {
		__values = append(__values, update.UptimeSuccessCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_success_count = ?"))
	}

	if update.TotalUptimeCount._set {
		__values = append(__values, update.TotalUptimeCount.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("total_uptime_count = ?"))
	}

	if update.UptimeRatio._set {
		__values = append(__values, update.UptimeRatio.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("uptime_ratio = ?"))
	}

	if update.LastContactSuccess._set {
		__values = append(__values, update.LastContactSuccess.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_success = ?"))
	}

	if update.LastContactFailure._set {
		__values = append(__values, update.LastContactFailure.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("last_contact_failure = ?"))
	}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("updated_at = ?"))

	__args = append(__args, node_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	node = &Node{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure FROM nodes WHERE nodes.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil
}

func (obj *sqlite3Impl) Update_User_By_Id(ctx context.Context,
	user_id User_Id_Field,
	update User_Update_Fields) (
	user *User, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE users SET "), __sets, __sqlbundle_Literal(" WHERE users.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.FullName._set {
		__values = append(__values, update.FullName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("full_name = ?"))
	}

	if update.ShortName._set {
		__values = append(__values, update.ShortName.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("short_name = ?"))
	}

	if update.Email._set {
		__values = append(__values, update.Email.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("email = ?"))
	}

	if update.PasswordHash._set {
		__values = append(__values, update.PasswordHash.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("password_hash = ?"))
	}

	if update.Status._set {
		__values = append(__values, update.Status.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("status = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, user_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	user = &User{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at FROM users WHERE users.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil
}

func (obj *sqlite3Impl) Update_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field,
	update Project_Update_Fields) (
	project *Project, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE projects SET "), __sets, __sqlbundle_Literal(" WHERE projects.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Description._set {
		__values = append(__values, update.Description.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("description = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, project_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	project = &Project{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects WHERE projects.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil
}

func (obj *sqlite3Impl) Update_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	update ApiKey_Update_Fields) (
	api_key *ApiKey, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE api_keys SET "), __sets, __sqlbundle_Literal(" WHERE api_keys.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.Name._set {
		__values = append(__values, update.Name.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("name = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, api_key_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	api_key = &ApiKey{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE api_keys.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil
}

func (obj *sqlite3Impl) Update_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field,
	update CertRecord_Update_Fields) (
	certRecord *CertRecord, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE certRecords SET "), __sets, __sqlbundle_Literal(" WHERE certRecords.id = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	__now := obj.db.Hooks.Now().UTC()

	__values = append(__values, __now)
	__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("update_at = ?"))

	__args = append(__args, certRecord_id.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	certRecord = &CertRecord{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE certRecords.id = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil
}

func (obj *sqlite3Impl) Update_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	update RegistrationToken_Update_Fields) (
	registration_token *RegistrationToken, err error) {
	var __sets = &__sqlbundle_Hole{}

	var __embed_stmt = __sqlbundle_Literals{Join: "", SQLs: []__sqlbundle_SQL{__sqlbundle_Literal("UPDATE registration_tokens SET "), __sets, __sqlbundle_Literal(" WHERE registration_tokens.secret = ?")}}

	__sets_sql := __sqlbundle_Literals{Join: ", "}
	var __values []interface{}
	var __args []interface{}

	if update.OwnerId._set {
		__values = append(__values, update.OwnerId.value())
		__sets_sql.SQLs = append(__sets_sql.SQLs, __sqlbundle_Literal("owner_id = ?"))
	}

	if len(__sets_sql.SQLs) == 0 {
		return nil, emptyUpdate()
	}

	__args = append(__args, registration_token_secret.value())

	__values = append(__values, __args...)
	__sets.SQL = __sets_sql

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	registration_token = &RegistrationToken{}
	_, err = obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return nil, obj.makeErr(err)
	}

	var __embed_stmt_get = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE registration_tokens.secret = ?")

	var __stmt_get = __sqlbundle_Render(obj.dialect, __embed_stmt_get)
	obj.logStmt("(IMPLIED) "+__stmt_get, __args...)

	err = obj.driver.QueryRow(__stmt_get, __args...).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil
}

func (obj *sqlite3Impl) Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM irreparabledbs WHERE irreparabledbs.segmentpath = ?")

	var __values []interface{}
	__values = append(__values, irreparabledb_segmentpath.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM accounting_rollups WHERE accounting_rollups.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_rollup_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_AccountingRaw_By_Id(ctx context.Context,
	accounting_raw_id AccountingRaw_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM accounting_raws WHERE accounting_raws.id = ?")

	var __values []interface{}
	__values = append(__values, accounting_raw_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM nodes WHERE nodes.id = ?")

	var __values []interface{}
	__values = append(__values, node_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Injuredsegment_By_Id(ctx context.Context,
	injuredsegment_id Injuredsegment_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM injuredsegments WHERE injuredsegments.id = ?")

	var __values []interface{}
	__values = append(__values, injuredsegment_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM users WHERE users.id = ?")

	var __values []interface{}
	__values = append(__values, user_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM projects WHERE projects.id = ?")

	var __values []interface{}
	__values = append(__values, project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM project_members WHERE project_members.member_id = ? AND project_members.project_id = ?")

	var __values []interface{}
	__values = append(__values, project_member_member_id.value(), project_member_project_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM api_keys WHERE api_keys.id = ?")

	var __values []interface{}
	__values = append(__values, api_key_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM bucket_usages WHERE bucket_usages.id = ?")

	var __values []interface{}
	__values = append(__values, bucket_usage_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
	serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
	count int64, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM serial_numbers WHERE serial_numbers.expires_at <= ?")

	var __values []interface{}
	__values = append(__values, serial_number_expires_at_less_or_equal.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return 0, obj.makeErr(err)
	}

	count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}

	return count, nil

}

func (obj *sqlite3Impl) Delete_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	deleted bool, err error) {

	var __embed_stmt = __sqlbundle_Literal("DELETE FROM certRecords WHERE certRecords.id = ?")

	var __values []interface{}
	__values = append(__values, certRecord_id.value())

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, __values...)

	__res, err := obj.driver.Exec(__stmt, __values...)
	if err != nil {
		return false, obj.makeErr(err)
	}

	__count, err := __res.RowsAffected()
	if err != nil {
		return false, obj.makeErr(err)
	}

	return __count > 0, nil

}

func (obj *sqlite3Impl) getLastIrreparabledb(ctx context.Context,
	pk int64) (
	irreparabledb *Irreparabledb, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT irreparabledbs.segmentpath, irreparabledbs.segmentdetail, irreparabledbs.pieces_lost_count, irreparabledbs.seg_damaged_unix_sec, irreparabledbs.repair_attempt_count FROM irreparabledbs WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	irreparabledb = &Irreparabledb{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&irreparabledb.Segmentpath, &irreparabledb.Segmentdetail, &irreparabledb.PiecesLostCount, &irreparabledb.SegDamagedUnixSec, &irreparabledb.RepairAttemptCount)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return irreparabledb, nil

}

func (obj *sqlite3Impl) getLastAccountingTimestamps(ctx context.Context,
	pk int64) (
	accounting_timestamps *AccountingTimestamps, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_timestamps.name, accounting_timestamps.value FROM accounting_timestamps WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	accounting_timestamps = &AccountingTimestamps{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&accounting_timestamps.Name, &accounting_timestamps.Value)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_timestamps, nil

}

func (obj *sqlite3Impl) getLastAccountingRollup(ctx context.Context,
	pk int64) (
	accounting_rollup *AccountingRollup, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_rollups.id, accounting_rollups.node_id, accounting_rollups.start_time, accounting_rollups.put_total, accounting_rollups.get_total, accounting_rollups.get_audit_total, accounting_rollups.get_repair_total, accounting_rollups.put_repair_total, accounting_rollups.at_rest_total FROM accounting_rollups WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	accounting_rollup = &AccountingRollup{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&accounting_rollup.Id, &accounting_rollup.NodeId, &accounting_rollup.StartTime, &accounting_rollup.PutTotal, &accounting_rollup.GetTotal, &accounting_rollup.GetAuditTotal, &accounting_rollup.GetRepairTotal, &accounting_rollup.PutRepairTotal, &accounting_rollup.AtRestTotal)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_rollup, nil

}

func (obj *sqlite3Impl) getLastAccountingRaw(ctx context.Context,
	pk int64) (
	accounting_raw *AccountingRaw, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT accounting_raws.id, accounting_raws.node_id, accounting_raws.interval_end_time, accounting_raws.data_total, accounting_raws.data_type, accounting_raws.created_at FROM accounting_raws WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	accounting_raw = &AccountingRaw{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&accounting_raw.Id, &accounting_raw.NodeId, &accounting_raw.IntervalEndTime, &accounting_raw.DataTotal, &accounting_raw.DataType, &accounting_raw.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return accounting_raw, nil

}

func (obj *sqlite3Impl) getLastNode(ctx context.Context,
	pk int64) (
	node *Node, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT nodes.id, nodes.address, nodes.protocol, nodes.type, nodes.email, nodes.wallet, nodes.free_bandwidth, nodes.free_disk, nodes.latency_90, nodes.audit_success_count, nodes.total_audit_count, nodes.audit_success_ratio, nodes.uptime_success_count, nodes.total_uptime_count, nodes.uptime_ratio, nodes.created_at, nodes.updated_at, nodes.last_contact_success, nodes.last_contact_failure FROM nodes WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	node = &Node{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&node.Id, &node.Address, &node.Protocol, &node.Type, &node.Email, &node.Wallet, &node.FreeBandwidth, &node.FreeDisk, &node.Latency90, &node.AuditSuccessCount, &node.TotalAuditCount, &node.AuditSuccessRatio, &node.UptimeSuccessCount, &node.TotalUptimeCount, &node.UptimeRatio, &node.CreatedAt, &node.UpdatedAt, &node.LastContactSuccess, &node.LastContactFailure)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return node, nil

}

func (obj *sqlite3Impl) getLastInjuredsegment(ctx context.Context,
	pk int64) (
	injuredsegment *Injuredsegment, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT injuredsegments.id, injuredsegments.info FROM injuredsegments WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	injuredsegment = &Injuredsegment{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&injuredsegment.Id, &injuredsegment.Info)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return injuredsegment, nil

}

func (obj *sqlite3Impl) getLastUser(ctx context.Context,
	pk int64) (
	user *User, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT users.id, users.full_name, users.short_name, users.email, users.password_hash, users.status, users.created_at FROM users WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	user = &User{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&user.Id, &user.FullName, &user.ShortName, &user.Email, &user.PasswordHash, &user.Status, &user.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return user, nil

}

func (obj *sqlite3Impl) getLastProject(ctx context.Context,
	pk int64) (
	project *Project, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT projects.id, projects.name, projects.description, projects.created_at FROM projects WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	project = &Project{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&project.Id, &project.Name, &project.Description, &project.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project, nil

}

func (obj *sqlite3Impl) getLastProjectMember(ctx context.Context,
	pk int64) (
	project_member *ProjectMember, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT project_members.member_id, project_members.project_id, project_members.created_at FROM project_members WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	project_member = &ProjectMember{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&project_member.MemberId, &project_member.ProjectId, &project_member.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return project_member, nil

}

func (obj *sqlite3Impl) getLastApiKey(ctx context.Context,
	pk int64) (
	api_key *ApiKey, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT api_keys.id, api_keys.project_id, api_keys.key, api_keys.name, api_keys.created_at FROM api_keys WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	api_key = &ApiKey{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&api_key.Id, &api_key.ProjectId, &api_key.Key, &api_key.Name, &api_key.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return api_key, nil

}

func (obj *sqlite3Impl) getLastBucketUsage(ctx context.Context,
	pk int64) (
	bucket_usage *BucketUsage, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_usages.id, bucket_usages.bucket_id, bucket_usages.rollup_end_time, bucket_usages.remote_stored_data, bucket_usages.inline_stored_data, bucket_usages.remote_segments, bucket_usages.inline_segments, bucket_usages.objects, bucket_usages.metadata_size, bucket_usages.repair_egress, bucket_usages.get_egress, bucket_usages.audit_egress FROM bucket_usages WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	bucket_usage = &BucketUsage{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&bucket_usage.Id, &bucket_usage.BucketId, &bucket_usage.RollupEndTime, &bucket_usage.RemoteStoredData, &bucket_usage.InlineStoredData, &bucket_usage.RemoteSegments, &bucket_usage.InlineSegments, &bucket_usage.Objects, &bucket_usage.MetadataSize, &bucket_usage.RepairEgress, &bucket_usage.GetEgress, &bucket_usage.AuditEgress)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_usage, nil

}

func (obj *sqlite3Impl) getLastSerialNumber(ctx context.Context,
	pk int64) (
	serial_number *SerialNumber, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT serial_numbers.id, serial_numbers.serial_number, serial_numbers.bucket_id, serial_numbers.expires_at FROM serial_numbers WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	serial_number = &SerialNumber{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&serial_number.Id, &serial_number.SerialNumber, &serial_number.BucketId, &serial_number.ExpiresAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return serial_number, nil

}

func (obj *sqlite3Impl) getLastUsedSerial(ctx context.Context,
	pk int64) (
	used_serial *UsedSerial, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT used_serials.serial_number_id, used_serials.storage_node_id FROM used_serials WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	used_serial = &UsedSerial{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&used_serial.SerialNumberId, &used_serial.StorageNodeId)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return used_serial, nil

}

func (obj *sqlite3Impl) getLastBucketStorageTally(ctx context.Context,
	pk int64) (
	bucket_storage_tally *BucketStorageTally, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT bucket_storage_tallies.bucket_id, bucket_storage_tallies.interval_start, bucket_storage_tallies.inline, bucket_storage_tallies.remote, bucket_storage_tallies.remote_segments_count, bucket_storage_tallies.inline_segments_count, bucket_storage_tallies.object_count, bucket_storage_tallies.metadata_size FROM bucket_storage_tallies WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	bucket_storage_tally = &BucketStorageTally{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&bucket_storage_tally.BucketId, &bucket_storage_tally.IntervalStart, &bucket_storage_tally.Inline, &bucket_storage_tally.Remote, &bucket_storage_tally.RemoteSegmentsCount, &bucket_storage_tally.InlineSegmentsCount, &bucket_storage_tally.ObjectCount, &bucket_storage_tally.MetadataSize)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return bucket_storage_tally, nil

}

func (obj *sqlite3Impl) getLastCertRecord(ctx context.Context,
	pk int64) (
	certRecord *CertRecord, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT certRecords.publickey, certRecords.id, certRecords.update_at FROM certRecords WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	certRecord = &CertRecord{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&certRecord.Publickey, &certRecord.Id, &certRecord.UpdateAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return certRecord, nil

}

func (obj *sqlite3Impl) getLastRegistrationToken(ctx context.Context,
	pk int64) (
	registration_token *RegistrationToken, err error) {

	var __embed_stmt = __sqlbundle_Literal("SELECT registration_tokens.secret, registration_tokens.owner_id, registration_tokens.project_limit, registration_tokens.created_at FROM registration_tokens WHERE _rowid_ = ?")

	var __stmt = __sqlbundle_Render(obj.dialect, __embed_stmt)
	obj.logStmt(__stmt, pk)

	registration_token = &RegistrationToken{}
	err = obj.driver.QueryRow(__stmt, pk).Scan(&registration_token.Secret, &registration_token.OwnerId, &registration_token.ProjectLimit, &registration_token.CreatedAt)
	if err != nil {
		return nil, obj.makeErr(err)
	}
	return registration_token, nil

}

func (impl sqlite3Impl) isConstraintError(err error) (
	constraint string, ok bool) {
	if e, ok := err.(sqlite3.Error); ok {
		if e.Code == sqlite3.ErrConstraint {
			msg := err.Error()
			colon := strings.LastIndex(msg, ":")
			if colon != -1 {
				return strings.TrimSpace(msg[colon:]), true
			}
			return "", true
		}
	}
	return "", false
}

func (obj *sqlite3Impl) deleteAll(ctx context.Context) (count int64, err error) {
	var __res sql.Result
	var __count int64
	__res, err = obj.driver.Exec("DELETE FROM used_serials;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM project_members;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM api_keys;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM users;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM storagenode_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM serial_numbers;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM registration_tokens;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM projects;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM nodes;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM irreparabledbs;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM injuredsegments;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM certRecords;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bwagreements;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_usages;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_storage_tallies;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM bucket_bandwidth_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_timestamps;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_rollups;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count
	__res, err = obj.driver.Exec("DELETE FROM accounting_raws;")
	if err != nil {
		return 0, obj.makeErr(err)
	}

	__count, err = __res.RowsAffected()
	if err != nil {
		return 0, obj.makeErr(err)
	}
	count += __count

	return count, nil

}

type Rx struct {
	db *DB
	tx *Tx
}

func (rx *Rx) UnsafeTx(ctx context.Context) (unsafe_tx *sql.Tx, err error) {
	tx, err := rx.getTx(ctx)
	if err != nil {
		return nil, err
	}
	return tx.Tx, nil
}

func (rx *Rx) getTx(ctx context.Context) (tx *Tx, err error) {
	if rx.tx == nil {
		if rx.tx, err = rx.db.Open(ctx); err != nil {
			return nil, err
		}
	}
	return rx.tx, nil
}

func (rx *Rx) Rebind(s string) string {
	return rx.db.Rebind(s)
}

func (rx *Rx) Commit() (err error) {
	if rx.tx != nil {
		err = rx.tx.Commit()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) Rollback() (err error) {
	if rx.tx != nil {
		err = rx.tx.Rollback()
		rx.tx = nil
	}
	return err
}

func (rx *Rx) All_AccountingRaw(ctx context.Context) (
	rows []*AccountingRaw, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_AccountingRaw(ctx)
}

func (rx *Rx) All_AccountingRaw_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
	accounting_raw_interval_end_time_greater_or_equal AccountingRaw_IntervalEndTime_Field) (
	rows []*AccountingRaw, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_AccountingRaw_By_IntervalEndTime_GreaterOrEqual(ctx, accounting_raw_interval_end_time_greater_or_equal)
}

func (rx *Rx) All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
	accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
	rows []*AccountingRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx, accounting_rollup_start_time_greater_or_equal)
}

func (rx *Rx) All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
	api_key_project_id ApiKey_ProjectId_Field) (
	rows []*ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx, api_key_project_id)
}

func (rx *Rx) All_Node_Id(ctx context.Context) (
	rows []*Id_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Node_Id(ctx)
}

func (rx *Rx) All_Project(ctx context.Context) (
	rows []*Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Project(ctx)
}

func (rx *Rx) All_ProjectMember_By_MemberId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*ProjectMember, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_ProjectMember_By_MemberId(ctx, project_member_member_id)
}

func (rx *Rx) All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field) (
	rows []*Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx, project_member_member_id)
}

func (rx *Rx) Create_AccountingRaw(ctx context.Context,
	accounting_raw_node_id AccountingRaw_NodeId_Field,
	accounting_raw_interval_end_time AccountingRaw_IntervalEndTime_Field,
	accounting_raw_data_total AccountingRaw_DataTotal_Field,
	accounting_raw_data_type AccountingRaw_DataType_Field,
	accounting_raw_created_at AccountingRaw_CreatedAt_Field) (
	accounting_raw *AccountingRaw, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_AccountingRaw(ctx, accounting_raw_node_id, accounting_raw_interval_end_time, accounting_raw_data_total, accounting_raw_data_type, accounting_raw_created_at)

}

func (rx *Rx) Create_AccountingRollup(ctx context.Context,
	accounting_rollup_node_id AccountingRollup_NodeId_Field,
	accounting_rollup_start_time AccountingRollup_StartTime_Field,
	accounting_rollup_put_total AccountingRollup_PutTotal_Field,
	accounting_rollup_get_total AccountingRollup_GetTotal_Field,
	accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
	accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
	accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
	accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
	accounting_rollup *AccountingRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_AccountingRollup(ctx, accounting_rollup_node_id, accounting_rollup_start_time, accounting_rollup_put_total, accounting_rollup_get_total, accounting_rollup_get_audit_total, accounting_rollup_get_repair_total, accounting_rollup_put_repair_total, accounting_rollup_at_rest_total)

}

func (rx *Rx) Create_AccountingTimestamps(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	accounting_timestamps_value AccountingTimestamps_Value_Field) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_AccountingTimestamps(ctx, accounting_timestamps_name, accounting_timestamps_value)

}

func (rx *Rx) Create_ApiKey(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	api_key_project_id ApiKey_ProjectId_Field,
	api_key_key ApiKey_Key_Field,
	api_key_name ApiKey_Name_Field) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ApiKey(ctx, api_key_id, api_key_project_id, api_key_key, api_key_name)

}

func (rx *Rx) Create_BucketStorageTally(ctx context.Context,
	bucket_storage_tally_bucket_id BucketStorageTally_BucketId_Field,
	bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
	bucket_storage_tally_inline BucketStorageTally_Inline_Field,
	bucket_storage_tally_remote BucketStorageTally_Remote_Field,
	bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
	bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
	bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
	bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
	bucket_storage_tally *BucketStorageTally, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_BucketStorageTally(ctx, bucket_storage_tally_bucket_id, bucket_storage_tally_interval_start, bucket_storage_tally_inline, bucket_storage_tally_remote, bucket_storage_tally_remote_segments_count, bucket_storage_tally_inline_segments_count, bucket_storage_tally_object_count, bucket_storage_tally_metadata_size)

}

func (rx *Rx) Create_BucketUsage(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
	bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
	bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
	bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
	bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
	bucket_usage_objects BucketUsage_Objects_Field,
	bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
	bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
	bucket_usage_get_egress BucketUsage_GetEgress_Field,
	bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
	bucket_usage *BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_BucketUsage(ctx, bucket_usage_id, bucket_usage_bucket_id, bucket_usage_rollup_end_time, bucket_usage_remote_stored_data, bucket_usage_inline_stored_data, bucket_usage_remote_segments, bucket_usage_inline_segments, bucket_usage_objects, bucket_usage_metadata_size, bucket_usage_repair_egress, bucket_usage_get_egress, bucket_usage_audit_egress)

}

func (rx *Rx) Create_CertRecord(ctx context.Context,
	certRecord_publickey CertRecord_Publickey_Field,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_CertRecord(ctx, certRecord_publickey, certRecord_id)

}

func (rx *Rx) Create_Injuredsegment(ctx context.Context,
	injuredsegment_info Injuredsegment_Info_Field) (
	injuredsegment *Injuredsegment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Injuredsegment(ctx, injuredsegment_info)

}

func (rx *Rx) Create_Irreparabledb(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
	irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
	irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
	irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
	irreparabledb *Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Irreparabledb(ctx, irreparabledb_segmentpath, irreparabledb_segmentdetail, irreparabledb_pieces_lost_count, irreparabledb_seg_damaged_unix_sec, irreparabledb_repair_attempt_count)

}

func (rx *Rx) Create_Node(ctx context.Context,
	node_id Node_Id_Field,
	node_address Node_Address_Field,
	node_protocol Node_Protocol_Field,
	node_type Node_Type_Field,
	node_email Node_Email_Field,
	node_wallet Node_Wallet_Field,
	node_free_bandwidth Node_FreeBandwidth_Field,
	node_free_disk Node_FreeDisk_Field,
	node_latency_90 Node_Latency90_Field,
	node_audit_success_count Node_AuditSuccessCount_Field,
	node_total_audit_count Node_TotalAuditCount_Field,
	node_audit_success_ratio Node_AuditSuccessRatio_Field,
	node_uptime_success_count Node_UptimeSuccessCount_Field,
	node_total_uptime_count Node_TotalUptimeCount_Field,
	node_uptime_ratio Node_UptimeRatio_Field,
	node_last_contact_success Node_LastContactSuccess_Field,
	node_last_contact_failure Node_LastContactFailure_Field) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Node(ctx, node_id, node_address, node_protocol, node_type, node_email, node_wallet, node_free_bandwidth, node_free_disk, node_latency_90, node_audit_success_count, node_total_audit_count, node_audit_success_ratio, node_uptime_success_count, node_total_uptime_count, node_uptime_ratio, node_last_contact_success, node_last_contact_failure)

}

func (rx *Rx) Create_Project(ctx context.Context,
	project_id Project_Id_Field,
	project_name Project_Name_Field,
	project_description Project_Description_Field) (
	project *Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_Project(ctx, project_id, project_name, project_description)

}

func (rx *Rx) Create_ProjectMember(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	project_member *ProjectMember, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_ProjectMember(ctx, project_member_member_id, project_member_project_id)

}

func (rx *Rx) Create_RegistrationToken(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	registration_token_project_limit RegistrationToken_ProjectLimit_Field,
	optional RegistrationToken_Create_Fields) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_RegistrationToken(ctx, registration_token_secret, registration_token_project_limit, optional)

}

func (rx *Rx) Create_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field,
	serial_number_bucket_id SerialNumber_BucketId_Field,
	serial_number_expires_at SerialNumber_ExpiresAt_Field) (
	serial_number *SerialNumber, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_SerialNumber(ctx, serial_number_serial_number, serial_number_bucket_id, serial_number_expires_at)

}

func (rx *Rx) Create_UsedSerial(ctx context.Context,
	used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
	used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
	used_serial *UsedSerial, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_UsedSerial(ctx, used_serial_serial_number_id, used_serial_storage_node_id)

}

func (rx *Rx) Create_User(ctx context.Context,
	user_id User_Id_Field,
	user_full_name User_FullName_Field,
	user_email User_Email_Field,
	user_password_hash User_PasswordHash_Field,
	optional User_Create_Fields) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Create_User(ctx, user_id, user_full_name, user_email, user_password_hash, optional)

}

func (rx *Rx) Delete_AccountingRaw_By_Id(ctx context.Context,
	accounting_raw_id AccountingRaw_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_AccountingRaw_By_Id(ctx, accounting_raw_id)
}

func (rx *Rx) Delete_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_AccountingRollup_By_Id(ctx, accounting_rollup_id)
}

func (rx *Rx) Delete_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ApiKey_By_Id(ctx, api_key_id)
}

func (rx *Rx) Delete_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_BucketUsage_By_Id(ctx, bucket_usage_id)
}

func (rx *Rx) Delete_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_CertRecord_By_Id(ctx, certRecord_id)
}

func (rx *Rx) Delete_Injuredsegment_By_Id(ctx context.Context,
	injuredsegment_id Injuredsegment_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Injuredsegment_By_Id(ctx, injuredsegment_id)
}

func (rx *Rx) Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Irreparabledb_By_Segmentpath(ctx, irreparabledb_segmentpath)
}

func (rx *Rx) Delete_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Node_By_Id(ctx, node_id)
}

func (rx *Rx) Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
	project_member_member_id ProjectMember_MemberId_Field,
	project_member_project_id ProjectMember_ProjectId_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_ProjectMember_By_MemberId_And_ProjectId(ctx, project_member_member_id, project_member_project_id)
}

func (rx *Rx) Delete_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_Project_By_Id(ctx, project_id)
}

func (rx *Rx) Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
	serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
	count int64, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx, serial_number_expires_at_less_or_equal)

}

func (rx *Rx) Delete_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	deleted bool, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Delete_User_By_Id(ctx, user_id)
}

func (rx *Rx) Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field) (
	row *Value_Row, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_AccountingTimestamps_Value_By_Name(ctx, accounting_timestamps_name)
}

func (rx *Rx) Find_SerialNumber_By_SerialNumber(ctx context.Context,
	serial_number_serial_number SerialNumber_SerialNumber_Field) (
	serial_number *SerialNumber, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Find_SerialNumber_By_SerialNumber(ctx, serial_number_serial_number)
}

func (rx *Rx) First_Injuredsegment(ctx context.Context) (
	injuredsegment *Injuredsegment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.First_Injuredsegment(ctx)
}

func (rx *Rx) Get_AccountingRaw_By_Id(ctx context.Context,
	accounting_raw_id AccountingRaw_Id_Field) (
	accounting_raw *AccountingRaw, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_AccountingRaw_By_Id(ctx, accounting_raw_id)
}

func (rx *Rx) Get_AccountingRollup_By_Id(ctx context.Context,
	accounting_rollup_id AccountingRollup_Id_Field) (
	accounting_rollup *AccountingRollup, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_AccountingRollup_By_Id(ctx, accounting_rollup_id)
}

func (rx *Rx) Get_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ApiKey_By_Id(ctx, api_key_id)
}

func (rx *Rx) Get_ApiKey_By_Key(ctx context.Context,
	api_key_key ApiKey_Key_Field) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_ApiKey_By_Key(ctx, api_key_key)
}

func (rx *Rx) Get_BucketUsage_By_Id(ctx context.Context,
	bucket_usage_id BucketUsage_Id_Field) (
	bucket_usage *BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_BucketUsage_By_Id(ctx, bucket_usage_id)
}

func (rx *Rx) Get_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field) (
	certRecord *CertRecord, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_CertRecord_By_Id(ctx, certRecord_id)
}

func (rx *Rx) Get_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
	irreparabledb *Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Irreparabledb_By_Segmentpath(ctx, irreparabledb_segmentpath)
}

func (rx *Rx) Get_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Node_By_Id(ctx, node_id)
}

func (rx *Rx) Get_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field) (
	project *Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_Project_By_Id(ctx, project_id)
}

func (rx *Rx) Get_RegistrationToken_By_OwnerId(ctx context.Context,
	registration_token_owner_id RegistrationToken_OwnerId_Field) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_RegistrationToken_By_OwnerId(ctx, registration_token_owner_id)
}

func (rx *Rx) Get_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_RegistrationToken_By_Secret(ctx, registration_token_secret)
}

func (rx *Rx) Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
	user_email User_Email_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_User_By_Email_And_Status_Not_Number(ctx, user_email)
}

func (rx *Rx) Get_User_By_Id(ctx context.Context,
	user_id User_Id_Field) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Get_User_By_Id(ctx, user_id)
}

func (rx *Rx) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx, bucket_usage_bucket_id, bucket_usage_rollup_end_time_greater, bucket_usage_rollup_end_time_less_or_equal, limit, offset)
}

func (rx *Rx) Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
	bucket_usage_bucket_id BucketUsage_BucketId_Field,
	bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
	bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
	limit int, offset int64) (
	rows []*BucketUsage, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx, bucket_usage_bucket_id, bucket_usage_rollup_end_time_greater, bucket_usage_rollup_end_time_less_or_equal, limit, offset)
}

func (rx *Rx) Limited_Injuredsegment(ctx context.Context,
	limit int, offset int64) (
	rows []*Injuredsegment, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_Injuredsegment(ctx, limit, offset)
}

func (rx *Rx) Limited_Irreparabledb_OrderBy_Asc_Segmentpath(ctx context.Context,
	limit int, offset int64) (
	rows []*Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_Irreparabledb_OrderBy_Asc_Segmentpath(ctx, limit, offset)
}

func (rx *Rx) Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
	node_id_greater_or_equal Node_Id_Field,
	limit int, offset int64) (
	rows []*Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx, node_id_greater_or_equal, limit, offset)
}

func (rx *Rx) Limited_ProjectMember_By_ProjectId(ctx context.Context,
	project_member_project_id ProjectMember_ProjectId_Field,
	limit int, offset int64) (
	rows []*ProjectMember, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Limited_ProjectMember_By_ProjectId(ctx, project_member_project_id, limit, offset)
}

func (rx *Rx) Update_AccountingTimestamps_By_Name(ctx context.Context,
	accounting_timestamps_name AccountingTimestamps_Name_Field,
	update AccountingTimestamps_Update_Fields) (
	accounting_timestamps *AccountingTimestamps, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_AccountingTimestamps_By_Name(ctx, accounting_timestamps_name, update)
}

func (rx *Rx) Update_ApiKey_By_Id(ctx context.Context,
	api_key_id ApiKey_Id_Field,
	update ApiKey_Update_Fields) (
	api_key *ApiKey, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_ApiKey_By_Id(ctx, api_key_id, update)
}

func (rx *Rx) Update_CertRecord_By_Id(ctx context.Context,
	certRecord_id CertRecord_Id_Field,
	update CertRecord_Update_Fields) (
	certRecord *CertRecord, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_CertRecord_By_Id(ctx, certRecord_id, update)
}

func (rx *Rx) Update_Irreparabledb_By_Segmentpath(ctx context.Context,
	irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
	update Irreparabledb_Update_Fields) (
	irreparabledb *Irreparabledb, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Irreparabledb_By_Segmentpath(ctx, irreparabledb_segmentpath, update)
}

func (rx *Rx) Update_Node_By_Id(ctx context.Context,
	node_id Node_Id_Field,
	update Node_Update_Fields) (
	node *Node, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Node_By_Id(ctx, node_id, update)
}

func (rx *Rx) Update_Project_By_Id(ctx context.Context,
	project_id Project_Id_Field,
	update Project_Update_Fields) (
	project *Project, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_Project_By_Id(ctx, project_id, update)
}

func (rx *Rx) Update_RegistrationToken_By_Secret(ctx context.Context,
	registration_token_secret RegistrationToken_Secret_Field,
	update RegistrationToken_Update_Fields) (
	registration_token *RegistrationToken, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_RegistrationToken_By_Secret(ctx, registration_token_secret, update)
}

func (rx *Rx) Update_User_By_Id(ctx context.Context,
	user_id User_Id_Field,
	update User_Update_Fields) (
	user *User, err error) {
	var tx *Tx
	if tx, err = rx.getTx(ctx); err != nil {
		return
	}
	return tx.Update_User_By_Id(ctx, user_id, update)
}

type Methods interface {
	All_AccountingRaw(ctx context.Context) (
		rows []*AccountingRaw, err error)

	All_AccountingRaw_By_IntervalEndTime_GreaterOrEqual(ctx context.Context,
		accounting_raw_interval_end_time_greater_or_equal AccountingRaw_IntervalEndTime_Field) (
		rows []*AccountingRaw, err error)

	All_AccountingRollup_By_StartTime_GreaterOrEqual(ctx context.Context,
		accounting_rollup_start_time_greater_or_equal AccountingRollup_StartTime_Field) (
		rows []*AccountingRollup, err error)

	All_ApiKey_By_ProjectId_OrderBy_Asc_Name(ctx context.Context,
		api_key_project_id ApiKey_ProjectId_Field) (
		rows []*ApiKey, err error)

	All_Node_Id(ctx context.Context) (
		rows []*Id_Row, err error)

	All_Project(ctx context.Context) (
		rows []*Project, err error)

	All_ProjectMember_By_MemberId(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field) (
		rows []*ProjectMember, err error)

	All_Project_By_ProjectMember_MemberId_OrderBy_Asc_Project_Name(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field) (
		rows []*Project, err error)

	Create_AccountingRaw(ctx context.Context,
		accounting_raw_node_id AccountingRaw_NodeId_Field,
		accounting_raw_interval_end_time AccountingRaw_IntervalEndTime_Field,
		accounting_raw_data_total AccountingRaw_DataTotal_Field,
		accounting_raw_data_type AccountingRaw_DataType_Field,
		accounting_raw_created_at AccountingRaw_CreatedAt_Field) (
		accounting_raw *AccountingRaw, err error)

	Create_AccountingRollup(ctx context.Context,
		accounting_rollup_node_id AccountingRollup_NodeId_Field,
		accounting_rollup_start_time AccountingRollup_StartTime_Field,
		accounting_rollup_put_total AccountingRollup_PutTotal_Field,
		accounting_rollup_get_total AccountingRollup_GetTotal_Field,
		accounting_rollup_get_audit_total AccountingRollup_GetAuditTotal_Field,
		accounting_rollup_get_repair_total AccountingRollup_GetRepairTotal_Field,
		accounting_rollup_put_repair_total AccountingRollup_PutRepairTotal_Field,
		accounting_rollup_at_rest_total AccountingRollup_AtRestTotal_Field) (
		accounting_rollup *AccountingRollup, err error)

	Create_AccountingTimestamps(ctx context.Context,
		accounting_timestamps_name AccountingTimestamps_Name_Field,
		accounting_timestamps_value AccountingTimestamps_Value_Field) (
		accounting_timestamps *AccountingTimestamps, err error)

	Create_ApiKey(ctx context.Context,
		api_key_id ApiKey_Id_Field,
		api_key_project_id ApiKey_ProjectId_Field,
		api_key_key ApiKey_Key_Field,
		api_key_name ApiKey_Name_Field) (
		api_key *ApiKey, err error)

	Create_BucketStorageTally(ctx context.Context,
		bucket_storage_tally_bucket_id BucketStorageTally_BucketId_Field,
		bucket_storage_tally_interval_start BucketStorageTally_IntervalStart_Field,
		bucket_storage_tally_inline BucketStorageTally_Inline_Field,
		bucket_storage_tally_remote BucketStorageTally_Remote_Field,
		bucket_storage_tally_remote_segments_count BucketStorageTally_RemoteSegmentsCount_Field,
		bucket_storage_tally_inline_segments_count BucketStorageTally_InlineSegmentsCount_Field,
		bucket_storage_tally_object_count BucketStorageTally_ObjectCount_Field,
		bucket_storage_tally_metadata_size BucketStorageTally_MetadataSize_Field) (
		bucket_storage_tally *BucketStorageTally, err error)

	Create_BucketUsage(ctx context.Context,
		bucket_usage_id BucketUsage_Id_Field,
		bucket_usage_bucket_id BucketUsage_BucketId_Field,
		bucket_usage_rollup_end_time BucketUsage_RollupEndTime_Field,
		bucket_usage_remote_stored_data BucketUsage_RemoteStoredData_Field,
		bucket_usage_inline_stored_data BucketUsage_InlineStoredData_Field,
		bucket_usage_remote_segments BucketUsage_RemoteSegments_Field,
		bucket_usage_inline_segments BucketUsage_InlineSegments_Field,
		bucket_usage_objects BucketUsage_Objects_Field,
		bucket_usage_metadata_size BucketUsage_MetadataSize_Field,
		bucket_usage_repair_egress BucketUsage_RepairEgress_Field,
		bucket_usage_get_egress BucketUsage_GetEgress_Field,
		bucket_usage_audit_egress BucketUsage_AuditEgress_Field) (
		bucket_usage *BucketUsage, err error)

	Create_CertRecord(ctx context.Context,
		certRecord_publickey CertRecord_Publickey_Field,
		certRecord_id CertRecord_Id_Field) (
		certRecord *CertRecord, err error)

	Create_Injuredsegment(ctx context.Context,
		injuredsegment_info Injuredsegment_Info_Field) (
		injuredsegment *Injuredsegment, err error)

	Create_Irreparabledb(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
		irreparabledb_segmentdetail Irreparabledb_Segmentdetail_Field,
		irreparabledb_pieces_lost_count Irreparabledb_PiecesLostCount_Field,
		irreparabledb_seg_damaged_unix_sec Irreparabledb_SegDamagedUnixSec_Field,
		irreparabledb_repair_attempt_count Irreparabledb_RepairAttemptCount_Field) (
		irreparabledb *Irreparabledb, err error)

	Create_Node(ctx context.Context,
		node_id Node_Id_Field,
		node_address Node_Address_Field,
		node_protocol Node_Protocol_Field,
		node_type Node_Type_Field,
		node_email Node_Email_Field,
		node_wallet Node_Wallet_Field,
		node_free_bandwidth Node_FreeBandwidth_Field,
		node_free_disk Node_FreeDisk_Field,
		node_latency_90 Node_Latency90_Field,
		node_audit_success_count Node_AuditSuccessCount_Field,
		node_total_audit_count Node_TotalAuditCount_Field,
		node_audit_success_ratio Node_AuditSuccessRatio_Field,
		node_uptime_success_count Node_UptimeSuccessCount_Field,
		node_total_uptime_count Node_TotalUptimeCount_Field,
		node_uptime_ratio Node_UptimeRatio_Field,
		node_last_contact_success Node_LastContactSuccess_Field,
		node_last_contact_failure Node_LastContactFailure_Field) (
		node *Node, err error)

	Create_Project(ctx context.Context,
		project_id Project_Id_Field,
		project_name Project_Name_Field,
		project_description Project_Description_Field) (
		project *Project, err error)

	Create_ProjectMember(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field,
		project_member_project_id ProjectMember_ProjectId_Field) (
		project_member *ProjectMember, err error)

	Create_RegistrationToken(ctx context.Context,
		registration_token_secret RegistrationToken_Secret_Field,
		registration_token_project_limit RegistrationToken_ProjectLimit_Field,
		optional RegistrationToken_Create_Fields) (
		registration_token *RegistrationToken, err error)

	Create_SerialNumber(ctx context.Context,
		serial_number_serial_number SerialNumber_SerialNumber_Field,
		serial_number_bucket_id SerialNumber_BucketId_Field,
		serial_number_expires_at SerialNumber_ExpiresAt_Field) (
		serial_number *SerialNumber, err error)

	Create_UsedSerial(ctx context.Context,
		used_serial_serial_number_id UsedSerial_SerialNumberId_Field,
		used_serial_storage_node_id UsedSerial_StorageNodeId_Field) (
		used_serial *UsedSerial, err error)

	Create_User(ctx context.Context,
		user_id User_Id_Field,
		user_full_name User_FullName_Field,
		user_email User_Email_Field,
		user_password_hash User_PasswordHash_Field,
		optional User_Create_Fields) (
		user *User, err error)

	Delete_AccountingRaw_By_Id(ctx context.Context,
		accounting_raw_id AccountingRaw_Id_Field) (
		deleted bool, err error)

	Delete_AccountingRollup_By_Id(ctx context.Context,
		accounting_rollup_id AccountingRollup_Id_Field) (
		deleted bool, err error)

	Delete_ApiKey_By_Id(ctx context.Context,
		api_key_id ApiKey_Id_Field) (
		deleted bool, err error)

	Delete_BucketUsage_By_Id(ctx context.Context,
		bucket_usage_id BucketUsage_Id_Field) (
		deleted bool, err error)

	Delete_CertRecord_By_Id(ctx context.Context,
		certRecord_id CertRecord_Id_Field) (
		deleted bool, err error)

	Delete_Injuredsegment_By_Id(ctx context.Context,
		injuredsegment_id Injuredsegment_Id_Field) (
		deleted bool, err error)

	Delete_Irreparabledb_By_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
		deleted bool, err error)

	Delete_Node_By_Id(ctx context.Context,
		node_id Node_Id_Field) (
		deleted bool, err error)

	Delete_ProjectMember_By_MemberId_And_ProjectId(ctx context.Context,
		project_member_member_id ProjectMember_MemberId_Field,
		project_member_project_id ProjectMember_ProjectId_Field) (
		deleted bool, err error)

	Delete_Project_By_Id(ctx context.Context,
		project_id Project_Id_Field) (
		deleted bool, err error)

	Delete_SerialNumber_By_ExpiresAt_LessOrEqual(ctx context.Context,
		serial_number_expires_at_less_or_equal SerialNumber_ExpiresAt_Field) (
		count int64, err error)

	Delete_User_By_Id(ctx context.Context,
		user_id User_Id_Field) (
		deleted bool, err error)

	Find_AccountingTimestamps_Value_By_Name(ctx context.Context,
		accounting_timestamps_name AccountingTimestamps_Name_Field) (
		row *Value_Row, err error)

	Find_SerialNumber_By_SerialNumber(ctx context.Context,
		serial_number_serial_number SerialNumber_SerialNumber_Field) (
		serial_number *SerialNumber, err error)

	First_Injuredsegment(ctx context.Context) (
		injuredsegment *Injuredsegment, err error)

	Get_AccountingRaw_By_Id(ctx context.Context,
		accounting_raw_id AccountingRaw_Id_Field) (
		accounting_raw *AccountingRaw, err error)

	Get_AccountingRollup_By_Id(ctx context.Context,
		accounting_rollup_id AccountingRollup_Id_Field) (
		accounting_rollup *AccountingRollup, err error)

	Get_ApiKey_By_Id(ctx context.Context,
		api_key_id ApiKey_Id_Field) (
		api_key *ApiKey, err error)

	Get_ApiKey_By_Key(ctx context.Context,
		api_key_key ApiKey_Key_Field) (
		api_key *ApiKey, err error)

	Get_BucketUsage_By_Id(ctx context.Context,
		bucket_usage_id BucketUsage_Id_Field) (
		bucket_usage *BucketUsage, err error)

	Get_CertRecord_By_Id(ctx context.Context,
		certRecord_id CertRecord_Id_Field) (
		certRecord *CertRecord, err error)

	Get_Irreparabledb_By_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field) (
		irreparabledb *Irreparabledb, err error)

	Get_Node_By_Id(ctx context.Context,
		node_id Node_Id_Field) (
		node *Node, err error)

	Get_Project_By_Id(ctx context.Context,
		project_id Project_Id_Field) (
		project *Project, err error)

	Get_RegistrationToken_By_OwnerId(ctx context.Context,
		registration_token_owner_id RegistrationToken_OwnerId_Field) (
		registration_token *RegistrationToken, err error)

	Get_RegistrationToken_By_Secret(ctx context.Context,
		registration_token_secret RegistrationToken_Secret_Field) (
		registration_token *RegistrationToken, err error)

	Get_User_By_Email_And_Status_Not_Number(ctx context.Context,
		user_email User_Email_Field) (
		user *User, err error)

	Get_User_By_Id(ctx context.Context,
		user_id User_Id_Field) (
		user *User, err error)

	Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Asc_RollupEndTime(ctx context.Context,
		bucket_usage_bucket_id BucketUsage_BucketId_Field,
		bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
		bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
		limit int, offset int64) (
		rows []*BucketUsage, err error)

	Limited_BucketUsage_By_BucketId_And_RollupEndTime_Greater_And_RollupEndTime_LessOrEqual_OrderBy_Desc_RollupEndTime(ctx context.Context,
		bucket_usage_bucket_id BucketUsage_BucketId_Field,
		bucket_usage_rollup_end_time_greater BucketUsage_RollupEndTime_Field,
		bucket_usage_rollup_end_time_less_or_equal BucketUsage_RollupEndTime_Field,
		limit int, offset int64) (
		rows []*BucketUsage, err error)

	Limited_Injuredsegment(ctx context.Context,
		limit int, offset int64) (
		rows []*Injuredsegment, err error)

	Limited_Irreparabledb_OrderBy_Asc_Segmentpath(ctx context.Context,
		limit int, offset int64) (
		rows []*Irreparabledb, err error)

	Limited_Node_By_Id_GreaterOrEqual_OrderBy_Asc_Id(ctx context.Context,
		node_id_greater_or_equal Node_Id_Field,
		limit int, offset int64) (
		rows []*Node, err error)

	Limited_ProjectMember_By_ProjectId(ctx context.Context,
		project_member_project_id ProjectMember_ProjectId_Field,
		limit int, offset int64) (
		rows []*ProjectMember, err error)

	Update_AccountingTimestamps_By_Name(ctx context.Context,
		accounting_timestamps_name AccountingTimestamps_Name_Field,
		update AccountingTimestamps_Update_Fields) (
		accounting_timestamps *AccountingTimestamps, err error)

	Update_ApiKey_By_Id(ctx context.Context,
		api_key_id ApiKey_Id_Field,
		update ApiKey_Update_Fields) (
		api_key *ApiKey, err error)

	Update_CertRecord_By_Id(ctx context.Context,
		certRecord_id CertRecord_Id_Field,
		update CertRecord_Update_Fields) (
		certRecord *CertRecord, err error)

	Update_Irreparabledb_By_Segmentpath(ctx context.Context,
		irreparabledb_segmentpath Irreparabledb_Segmentpath_Field,
		update Irreparabledb_Update_Fields) (
		irreparabledb *Irreparabledb, err error)

	Update_Node_By_Id(ctx context.Context,
		node_id Node_Id_Field,
		update Node_Update_Fields) (
		node *Node, err error)

	Update_Project_By_Id(ctx context.Context,
		project_id Project_Id_Field,
		update Project_Update_Fields) (
		project *Project, err error)

	Update_RegistrationToken_By_Secret(ctx context.Context,
		registration_token_secret RegistrationToken_Secret_Field,
		update RegistrationToken_Update_Fields) (
		registration_token *RegistrationToken, err error)

	Update_User_By_Id(ctx context.Context,
		user_id User_Id_Field,
		update User_Update_Fields) (
		user *User, err error)
}

type TxMethods interface {
	Methods

	Rebind(s string) string
	Commit() error
	Rollback() error
}

type txMethods interface {
	TxMethods

	deleteAll(ctx context.Context) (int64, error)
	makeErr(err error) error
}

type DBMethods interface {
	Methods

	Schema() string
	Rebind(sql string) string
}

type dbMethods interface {
	DBMethods

	wrapTx(tx *sql.Tx) txMethods
	makeErr(err error) error
}

func openpostgres(source string) (*sql.DB, error) {
	return sql.Open("postgres", source)
}

var sqlite3DriverName = func() string {
	var id [16]byte
	rand.Read(id[:])
	return fmt.Sprintf("sqlite3_%x", string(id[:]))
}()

func init() {
	sql.Register(sqlite3DriverName, &sqlite3.SQLiteDriver{
		ConnectHook: sqlite3SetupConn,
	})
}

// SQLite3JournalMode controls the journal_mode pragma for all new connections.
// Since it is read without a mutex, it must be changed to the value you want
// before any Open calls.
var SQLite3JournalMode = "WAL"

func sqlite3SetupConn(conn *sqlite3.SQLiteConn) (err error) {
	_, err = conn.Exec("PRAGMA foreign_keys = ON", nil)
	if err != nil {
		return makeErr(err)
	}
	_, err = conn.Exec("PRAGMA journal_mode = "+SQLite3JournalMode, nil)
	if err != nil {
		return makeErr(err)
	}
	return nil
}

func opensqlite3(source string) (*sql.DB, error) {
	return sql.Open(sqlite3DriverName, source)
}
